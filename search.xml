<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数学 pre 项目计划表（24 春季学期）</title>
      <link href="/2024-03-16-my-math-pre-project-schedule/"/>
      <url>/2024-03-16-my-math-pre-project-schedule/</url>
      
        <content type="html"><![CDATA[<p>​本次项目的讨论起源于一个弹性力学问题。笔者在高二学习弹性力学时，曾尝试去推导环形弹簧振子链的简正模公式，并成功导出了一个与 Fourier 矩阵相关的结果。然而，笔者在求解 Fourier 矩阵的特征值与特征向量这一问题上，遇到了很大的困难。</p><p>​问题解决的转机出现在大一上学期。在线性代数课程中，笔者将这个问题拿去请教了当时任教的邬龙挺老师。在邬老师的指引下，笔者查阅了相关资料，发现这个问题不仅仅与弹性力学相关——它还可以与 Legendre 符号、Gauss 二次和、 数论的二次互反律等初等数论命题联系起来，并且更深入的讨论可以见于信号处理、函数变换、数值算法等应用数学领域。</p><p>​因此，笔者打算在这个学期较为深入地探讨这一问题，并将探究结果以报告的形式给大家展示出来，期待能引发大家的进一步讨论，从而产生更多的观点，最终实现同学之间的观点交流，相互促进。</p><span id="more"></span><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>​笔者预计完成以下目标：</p><ol><li>通过弹性力学问题，引入离散 Fourier 变换的相关讨论；</li><li>证明与 Fourier 矩阵相关的数论命题，并利用这些命题证明数论的二次互反律；</li><li>利用这些结果，推导出 Fourier 矩阵的特征向量的求解公式，进而解决该弹性力学问题；</li><li>设计特征向量的求解算法，并实现模拟程序；</li><li>将已解决的结果和进一步引申出的未解决的问题，写成报告和 LaTeX 幻灯片。</li></ol><p>​最终结果期望将在第 10 周或第 12 周的英才班讨论班中进行展示。</p><p>​由于问题涉及的知识面较宽，解决难度较大，因此至少需要一个半月至两个月（共 6-8 周）的准备时间。如果最终展示内容较多，必要时可能会分成两次报告。</p><hr><h4 id="具体进度表"><a href="#具体进度表" class="headerlink" title="具体进度表"></a>具体进度表</h4><p>​<strong>前三周已经完成的内容</strong></p><ul><li>证明 Legendre 符号 $\left( \frac {\cdot} {p} \right)$ 是完全积性函数；</li><li>证明离散 Fourier 变换（DFT）满足以下性质：<ol><li>DFT 是 $H_n &#x3D; \mathrm{Map} (\mathbb Z_n, \mathbb C)$ 到 $H_n$ 自身的 $\mathbb C$-线性变换，它把函数 $f(x)$ 映射到 $\hat f(x)$；</li><li>$H_n$ 的一组基是 $\delta_0, \delta_1, \cdots, \delta_{n - 1}$；DFT 在这组基下的矩阵是 $F_n &#x3D; [F_{ab}]<em>{n \times n}$，其中 $F</em>{ab} &#x3D; \mathrm e ^ {2 \pi \mathrm i \frac {ab} {n}}$；</li><li>矩阵 $F_n$ 的迹是 Gauss 二次和 $g_n$；</li></ol></li><li>证明 $h_p(x) &#x3D; \left( \frac {x} {p} \right)$ 是 DFT 的一个特征函数，且 $\hat h_p &#x3D; g_p h_p$；</li><li>证明离散 Fourier 逆变换（IDFT）公式：</li></ul><p>$$<br>f(x) &#x3D; \frac1n \sum _ {y &#x3D; 0} ^ {n - 1} \hat f(y) \mathrm e ^ {2 \pi \mathrm i \frac {xy} {n}}<br>$$</p><ul><li>证明 $g_p$ 的另一个表达形式：$g_p^2 &#x3D; \left( \frac {-1} {p} \right)$，从而：<ol><li>当 $p \equiv 1 \pmod 4$ 时，$g_p &#x3D; \pm \sqrt {p}$；</li><li>当 $p \equiv 3 \pmod 4$ 时，$g_p &#x3D; \pm \mathrm i \sqrt {p}$；</li></ol></li></ul><p>​<strong>接下来需要完成的证明和推导</strong></p><ul><li><p>定义 $U_n &#x3D; \frac {1} {\sqrt {n}} F_n$，以及 $\Phi_n: H_n \rightarrow H_n; f \mapsto \Phi_n(f) &#x3D; \frac 1 {\sqrt n} \hat f$，证明：</p><ol><li>$U_n$ 是酉矩阵，并联系 Plancherel 公式，做出类比。进而得到 $\Phi_n$ 是 $\mathrm {End}(H_n)$ 上的酉变换；</li><li>$\Phi_n^2(f)(x) &#x3D; f(-x)$；</li><li>$\Phi_n^4(f) &#x3D; f$；</li><li>$U_n^2$ 的特征值满足 $\lambda \in { \pm 1 }$，进而 $U_n$ 的特征值满足 $\lambda \in { \pm 1, \pm \mathrm i }$；</li><li>$U_n$ 的最小多项式是 $X^4 - 1$，从而 $U_n$ 可对角化</li></ol></li><li><p>（博客[1]的 <em>Lemma 3</em>）设 $n$ 是正奇数。$\Phi_n^2$ 的特征值和特征向量为：</p><ol><li>对应于 $\lambda &#x3D; 1$：$\delta_0, \delta_1 + \delta_{-1}, \delta_2 + \delta_{-2}, \cdots, \delta_{\frac {n - 1} {2}} + \delta_{-\frac {n - 1} {2}}$；</li><li>对应于 $\lambda &#x3D; -1$：$\delta_1 - \delta_{-1}, \delta_2 - \delta_{-2}, \cdots, \delta_{\frac {n - 1} {2}} - \delta_{-\frac {n - 1} {2}}$；</li></ol><p>且 $\Phi_n^2$ 的特征多项式是 $(X - 1) ^ {\frac {n + 1} {2}} (X + 1) ^ {\frac {n - 1} {2}}$；</p></li><li><p>（博客[1]的 <em>Lemma 4</em>）设 $n$ 是正奇数。令</p><p>$$<br>e(n) &#x3D;<br>\left{\begin{array}{c}<br>1, 当 n \equiv 1 \pmod 4 时 \<br>i, 当 n \equiv 3 \pmod 4 时<br>\end{array}\right.<br>$$</p><p>证明：如果 $U \in M_n(\mathbb C)$ 满足</p><ol><li>$U^2$ 的特征多项式是 $\left ( X-1 \right ) ^{\frac{n + 1}{2}} \left ( X+1 \right ) ^{\frac{n - 1}{2}}$；</li><li>$\det U &#x3D; i^{\frac{n(n-1)}{2}}$；</li><li>$\mathrm{Tr} (U) &#x3D; \pm e(n)$，但是未能确定符号；</li></ol><p>那么 $U$ 的特征多项式是：</p><ol><li>当 $n \equiv 1 \pmod 4$ 时，为 $(X-1)(X^4-1)^{\frac{n-1}{4}}$；</li><li>当 $n \equiv 3 \pmod 4$ 时，为 $(X-1)(X+1)(X-i)(X^4-1)^{\frac{n-3}{4}}$；</li></ol><p>并且 $\mathrm {Tr}(U) &#x3D; e(n)$ 的符号能够确定；</p></li><li><p>设 $n$ 是正奇数。证明 $\det U_n &#x3D; i^{\frac{n(n-1)}{2}}$；</p></li><li><p>（博客[1]的 <em>Corollary 1</em>）设 $p$ 是奇素数。</p><ol><li>当 $p \equiv 1 \pmod 4$ 时，$g_p &#x3D; \sqrt {p}$；</li><li>当 $p \equiv 3 \pmod 4$ 时，$g_p &#x3D; \mathrm i \sqrt {p}$；</li></ol></li><li><p>设 $n$ 是正奇数。证明 $\mathrm{Tr} (U) &#x3D; \pm e(n)$；</p></li><li><p>（博客[1]的 <em>Corollary 2</em>）设 $n$ 是正奇数。</p><ol><li>当 $n \equiv 1 \pmod 4$ 时，$g_n &#x3D; \sqrt {n}$；</li><li>当 $n \equiv 3 \pmod 4$ 时，$g_n &#x3D; \mathrm i \sqrt {n}$；</li></ol></li><li><p>（博客[1]的 <em>Lemma 7</em>）设 $p, q$ 是互异的奇素数。证明：<br>$$<br>\frac {g_{pq}} {g_p g_q} &#x3D; \left ( \frac {p} {q} \right ) \left ( \frac {q} {p} \right )<br>$$</p></li><li><p>证明 Gauss 二次互反律：设 $p, q$ 是互异的奇素数，那么：<br>$$<br>\left ( \frac {p} {q} \right ) \left ( \frac {q} {p} \right ) &#x3D;<br>\left{\begin{array}{r}<br>1, 当 p \equiv 1 或 q \equiv 1 \pmod 4 时\<br>-1, 当 p \equiv 3 且 q \equiv 3 \pmod 4 时<br>\end{array}\right.<br>$$</p></li></ul><p>​<strong>进一步阅读材料与程序编写计划</strong></p><p>​这一部分内容会在前面的内容完成后，补充细节计划。</p><ul><li>阅读额外材料[2][3]，研究关于离散 Fourier 变换、数论 Legendre 符号与 Heisenberg 群的进一步命题；</li><li>编制程序实现弹性力学的模拟算法，生成动图和分析数据；</li><li>写报告文档和 LaTeX slides；</li></ul><hr><h4 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h4><p>计划每两周记录一次进度节点，并尽量实现在第 10 周之前完成 80% 的内容。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] 数学博客 The Sign of the Quadratic Gauss Sum and Quadratic Reciprocity, <a href="https://mattbaker.blog/2015/04/30/the-sign-of-the-quadratic-gauss-sum-and-quadratic-reciprocity/">https://mattbaker.blog/2015/04/30/the-sign-of-the-quadratic-gauss-sum-and-quadratic-reciprocity/</a></p><p>[2] 论文 IS COMPUTING WITH THE FINITE FOURIER TRANSFORM PURE OR APPLIED MATHEMATICS, L. AUSLANDER AND R. TOLIMIERI, <a href="https://www.ams.org/journals/bull/1979-01-06/S0273-0979-1979-14686-X/S0273-0979-1979-14686-X.pdf">https://www.ams.org/journals/bull/1979-01-06/S0273-0979-1979-14686-X/S0273-0979-1979-14686-X.pdf</a></p><p>[3] 论文 ON THE DIAGONALIZATION OF THE DISCRETE FOURIER TRANSFORM, SHAMGAR GUREVICH AND RONNY HADANI, <a href="https://arxiv.org/pdf/0808.3281v2.pdf">https://arxiv.org/pdf/0808.3281v2.pdf</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dilworth 定理的证明</title>
      <link href="/2023-12-31-proof-of-dilworth-theorem/"/>
      <url>/2023-12-31-proof-of-dilworth-theorem/</url>
      
        <content type="html"><![CDATA[<p>在序理论和组合数学中，Dilworth 定理指出了在有限偏序集上，以偏序关系构成的链是如何覆盖整个偏序集的，进而可以导出后续的一些图论相关定理。</p><p><strong>定理（Dilworth）</strong> 设 $S$ 是有限的偏序集，则存在正整数 $k$，使得 $S$ 的所有链划分大小都不小于 $k$，$S$ 的所有反链大小都不大于 $k$，并且分别存在大小恰为 $k$ 的链划分和大小恰为 $k$ 的反链。</p><p>Dilworth 定理指出，在任意的有限偏序集中，最小链划分的大小等于最大反链的大小。</p><span id="more"></span><h1 id="概念和定义"><a href="#概念和定义" class="headerlink" title="概念和定义"></a>概念和定义</h1><p>为了描述什么是偏序集，我们先给出<strong>偏序</strong>的概念。</p><p><strong>定义 1（二元关系）</strong> 设 $S$ 是一个非空集合，$W$ 是 $S \times S$ 的一个子集，称为 $S$ 上的一个二元关系。对于任意的 $x, y \in S$，如果 $(x, y) \in W$，则称元素 $x$ 和 $y$ 有关系 $W$，记作 $x W y$。否则，若 $(x, y) \not \in W$，则称 $x$ 和 $y$ 没有关系 $W$。</p><p><strong>定义 2（偏序关系）</strong> 设 $\le$ 是 $S$ 上的一个二元关系，若 $\le$ 满足：</p><ul><li>（自反性）$\forall x \in S,$ 有 $x \le x$；</li><li>（反对称性）如果 $x \le y$ 且 $y \le x$，那么 $x &#x3D; y$；</li><li>（传递性）如果 $x \le y$ 且 $y \le z$，那么 $x \le z$；</li></ul><p>则称 $\le$ 是 $S$ 上的一个偏序关系，$(S, \le)$ 称为一个偏序集。如果 $x, y \in S$ 满足 $x \le y$ 或 $y \le x$，那么称 $x$ 和 $y$ 是可比较的。如果 $\forall x, y \in S$，都有 $x \le y$ 或 $y \le x$，则称 $\le$ 是 $S$ 上的一个全序关系，$(S, \le)$ 称为一个全序集。</p><p>注意 $\le$ 不一定是普通意义下的“小于等于”关系，下面我们给出一些例子。</p><p><strong>例 1（大小比较关系）</strong> 设 $S &#x3D; \mathbb {R}$，那么普通意义下的小于等于关系 $\le$ 是 $S$ 上的一个偏序关系，此时 $(S, \le)$ 是一个偏序集，而且是一个全序集。严格小于关系 $&lt;$ 不是 $S$ 上的一个偏序关系，因为自反性 $x &lt; x$ 对于 $S$ 中的任何元素都不满足。另外，大于等于关系 $\ge$ 也是 $S$ 上的一个偏序关系。</p><p><strong>例 2（集合的包含关系）</strong> 设 $S &#x3D; \mathcal{P}(\mathbb{Z})$，即 $S$ 是由所有可能的整数集构成的集合（$\mathbb{Z}$ 的幂集），那么 $\subset$ 是 $S$ 上的一个偏序关系，这里 $X \subset Y$ 当且仅当 $X$ 是 $Y$ 的子集。此时 $(S, \subset)$ 是一个偏序集，但不是一个全序集，因为存在不可比较的两个集合，任一方都不是对方的子集。</p><p><strong>例 3（树的祖先关系）</strong> 在图论中，设 $T$ 是树，对于 $T$ 上的任意两个节点 $x, y$，若 $x \leftarrow y$ 表示 $y$ 是 $x$ 的祖先，那么 $\leftarrow$ 是树 $T$ 上的一个偏序关系，但不是全序关系。</p><p><strong>定义 3（极大元）</strong> 设 $(S, \le)$ 是一个偏序集，如果 $a \in S$ 满足 $\forall x \in a, $ 有 $a \not \le x$，则称 $a$ 是 $S$ 中的一个极大元。</p><p>注意我们使用了 $\not \le$ 符号，而不是 $x \le a$，这是因为在 $S$ 中不是任意两个元素都可以比较大小的。</p><p>我们指出：任意有限的偏序集 $S$ 都至少存在一个极大元。</p><p><strong>引理 1（有限偏序集中极大元的存在性）</strong> 设 $(S, \le)$ 是一个有限的偏序集，那么 $\exists a \in S,$ 使得 $a$ 是 $S$ 的极大元。</p><p><strong>证明</strong></p><p>逐个考察 $S$ 中的元素。设 $S &#x3D; { x_1, \cdots, x_n }$，那么首先令 $a &#x3D; x_1$，然后检查 $a \le x_2$ 是否成立。如果 $a \le x_2$ 成立，那么令 $a &#x3D; x_2$；否则，如果 $a \not \le x_2$，那么保持 $a$ 不变。以此类推，最后得到一个元素 $a$。根据归纳假设以及偏序关系的传递性，$a$ 必然满足 $\forall x \in S,$ 有 $a \not \le x$。所以 $a$ 是 $S$ 的极大元，引理证毕。</p><p>如果 $C$ 是 $S$ 中的链（从而是全序集），那么 $C$ 的极大元是唯一的，称为 $C$ 的最大元。</p><p><strong>定义 4（链和反链）</strong> 设 $(S, \le)$ 是一个偏序集，如果 $C \subset S$ 满足 $C$ 中的任意两个元素都是可比较的，则称 $C$ 是 $S$ 中的链（chain）。如果 $A \subset S$ 满足 $A$ 中的任意两个元素都是不可比较的，则称 $A$ 是 $S$ 中的反链（antichain）。</p><p>规定 $S$ 的子集中，只含一个元素的集合既是链，又是反链。</p><h1 id="Dilworth-定理"><a href="#Dilworth-定理" class="headerlink" title="Dilworth 定理"></a>Dilworth 定理</h1><p>假设偏序集 $S$ 是有限的，那么将 $S$ 中的每个元素自身作为一个集合，这些集合就构成了 $S$ 的一个划分。这些集合也是链，所以这就构成了 $S$ 的一个<strong>链划分</strong>。基于此，我们给出正式的定义。</p><p><strong>定义 3（链划分）</strong> 设 $C_1, \cdots, C_k$ 是偏序集 $S$ 的一个划分，即 $C_i (i &#x3D; 1, \cdots, k)$ 两两不交，且其并集等于 $S$。若 $C_1, \cdots, C_k$ 都是链，则称 $C_1, \cdots, C_k$ 是 $S$ 的一个链划分，$k$ 称为这个链划分的大小。</p><p>Dilworth 定理指出，在任意的有限偏序集中，最小链划分的大小等于最大反链的大小。</p><p><strong>定理（Dilworth）</strong> 设 $S$ 是有限的偏序集，则存在正整数 $k$，使得 $S$ 的所有链划分大小都不小于 $k$，$S$ 的所有反链大小都不大于 $k$，并且分别存在大小恰为 $k$ 的链划分和大小恰为 $k$ 的反链。</p><h1 id="定理的证明"><a href="#定理的证明" class="headerlink" title="定理的证明"></a>定理的证明</h1><p>首先给出一个引理。</p><p><strong>引理 2</strong> 有限偏序集 $(S, \le)$ 的链划分大小不小于 $S$ 中的反链大小。</p><p><strong>证明</strong> 假设 $A$ 是 $S$ 中的一个反链，$C_1, \cdots, C_k$ 是 $S$ 的一个链划分，且 $A$ 的大小大于 $k$。根据鸽巢原理，存在某个 $C_i$，使得 $C_i$ 中有两个元素 $x, y$ 属于 $A$。那么由于 $x, y \in C_i$，所以 $x$ 和 $y$ 是可比较的。但是 $x, y \in A$，这与反链的定义矛盾。所以 $A$ 的大小不大于 $k$，引理证毕。</p><p>下面证明 Dilworth 定理。</p><p><strong>Dilworth 定理的证明</strong></p><p>采用数学归纳法。</p><p>首先，当集合 $S &#x3D; {x}$ 只有一个元素时，最大的反链为 ${x}$，最小的链划分为 $$，最大反链的大小等于最小链划分的大小。</p><p>其次，当集合 $S$ 有超过一个元素时，设 $a$ 为 $S$ 中的一个极大元，令 $S’ &#x3D; S \backslash {a}$，那么根据归纳假设，$S’$ 的最大反链大小等于最小链划分的大小。</p><p>设存在正整数 $k$ 使得 $S’$ 中存在至少一个大小为 $k$ 的反链 $A_0$，且存在 $S’$ 的一个大小为 $k$ 的链划分 $C_1, \cdots, C_k$。显然 $A_0 \cap C_i \neq \varnothing (i &#x3D; 1, \cdots, k)$，否则根据鸽巢原理，考虑到 $A_0$ 的大小为 $k$，就会有某个 $C_j$ 中的两个元素属于 $A_0$，矛盾。记 $x_i$ 为链 $C_i$ 中的最大元，我们证明 $A &#x3D; {x_1, \cdots, x_k}$ 是 $S$ 中的一个反链。</p><!-- 这里和维基百科上的证明原文不符，需要修改 --><p>设 $A_i$ 是 $S’$ 中的一个长为 $k$ 而且包含 $x_i$ 的反链，那么对于 $j \neq i$，必然有 $A_i \cap C_j \neq \varnothing$。于是，我们可以取 $y \in A_i \cap C_j$。由于 $x_j$ 是 $C_j$ 的最大元，所以 $y \le x_j$；由于 $y, x_i \in A_i$，所以 $y \not \le x_i$。根据偏序关系的传递性，$x_j \not \le x_i$（否则若 $x_j \le x_i$，那么 $y \le x_i$）。这就证明了，对于任意的 $i \neq j$，有 $x_j \not \le x_i$，也就是说，$A &#x3D; {x_1, \cdots, x_k}$ 是一个反链。</p><p>现在考虑 $S &#x3D; {a} \cup S’$。假设存在 $i \in {1, 2, \cdots, k}$，使得 $x_i \le a$，那么令 $K &#x3D; {a} \cap C_i$，$P \backslash K$ 一定有大小为 $k - 1$ 的链分解（在 $C_1, \cdots, C_k$ 中去掉 $C_i$ 即可），从而没有大小为 $k$ 的反链。由归纳假设可知，$A \backslash {x_i}$ 是 $P \backslash K$ 的一个大小为 $k - 1$ 的反链，从而 $k - 1$ 是 $P \backslash K$ 的最大反链大小。由于链分解大小不能小于反链大小，所以 $k - 1$ 也是 $P \backslash K$ 的最小链分解大小。</p><p>将 $K$ 加入到 $P \backslash K$ 的最小链分解中，得到一个大小为 $k$ 的链分解；再将 $a$ 加入到 $A \backslash {x_i}$ 中，得到一个大小为 $k$ 的反链。所以 $P$ 的最小链分解大小等于最大反链大小。</p><p>假设不存在 $i \in {1, 2, \cdots, k}$，使得 $x_i \le a$，那么由于 $a$ 是一个极大元，$a \le x_i$ 也不成立，所以 $A \cup {a}$ 就是 $S$ 的一个大小为 $k + 1$ 的反链。现在 ${a}, C_1, \cdots, C_k$ 就是 $S$ 的一个大小为 $k + 1$ 的链分解，所以最小链分解大小等于最大反链大小。</p><p>根据数学归纳法，定理证毕。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://en.wikipedia.org/wiki/Dilworth%27s_theorem">Dilworth’s theorem - Wikipedia</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序理论 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 luogu CF662C Binary Table（简要笔记）</title>
      <link href="/2020-04-07-sol-luogu-CF662C-brief/"/>
      <url>/2020-04-07-sol-luogu-CF662C-brief/</url>
      
        <content type="html"><![CDATA[<p>$\DeclareMathOperator {\xor} {\oplus}$FWT 入门<del>模板题</del></p><p>阅读这篇文章你需要：</p><ol><li>FWT 模板 <a href="../fwt-notes-detailed/">[Link↗]</a></li></ol><p>题面见链接 <a href="https://www.luogu.com.cn/problem/CF662C">[Link↗]</a></p><span id="more"></span><p>由于 $n \le 20$，考虑对行的翻转情况进行状态压缩。设 $f(S)$ 表示已经翻转集合 $S$ 中的行时的最小答案。</p><p>预处理 $v(S) &#x3D; \min(\mathrm {size} (S), \mathrm {size} (\lnot S))$。即可以翻转 $S$ 的情况下 $1$ 数量的最小值。</p><p>若第 $i$ 列的状态为 $T _ i$，则：</p><p>$$<br>f(S) &#x3D; \sum _ {i &#x3D; 0} ^ {m - 1} v(S \xor T _ i)<br>$$</p><p>运用一个下标转值域的技巧（<strong>将枚举下标转变为枚举值域</strong>），把枚举 $i \in [0, m)$ 变成枚举 $T _ i$ 的值</p><p>$$<br>\begin {split}<br>f(S) &amp;&#x3D; \sum _ {T} v(S \xor T) cnt(T) \<br>&amp;&#x3D; \sum _ {T} \sum _ {R} [R &#x3D; S \xor T] v(R) cnt(T) \<br>&amp;&#x3D; \sum _ {T} \sum _ {R} [R \xor T &#x3D; S] v(R) cnt(T)<br>\end {split}<br>$$</p><p>显然 $f(S)$ 就是 $v(R)$ 和 $cnt(T)$ 的异或卷积。用 FWT 计算即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">20</span> + <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxS = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[kMaxM];</span><br><span class="line"><span class="type">bool</span> a[kMaxN][kMaxM];</span><br><span class="line">LL cnt[kMaxS], val[kMaxS];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FwtXor</span><span class="params">(LL* a, <span class="type">int</span> blen, <span class="type">bool</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">      <span class="type">int</span> mid = i + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (len &gt;&gt; <span class="number">1</span>); ++j) &#123;</span><br><span class="line">        LL tmp1 = a[i + j] + a[mid + j];</span><br><span class="line">        LL tmp2 = a[i + j] - a[mid + j];</span><br><span class="line">        <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">          tmp1 /= <span class="number">2</span>;</span><br><span class="line">          tmp2 /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i + j] = tmp1;</span><br><span class="line">        a[mid + j] = tmp2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LowBit</span><span class="params">(<span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> S &amp; -S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">OneCount</span><span class="params">(<span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; S; S -= <span class="built_in">LowBit</span>(S)) ++ans;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">GetStr</span><span class="params">(<span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">  string ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    ans += ((<span class="type">bool</span>) (S &amp; (<span class="number">1</span> &lt;&lt; i))) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">      a[i][j] = (<span class="type">bool</span>) (str[j] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> S = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">      S |= (a[j][i] &lt;&lt; j);</span><br><span class="line">    ++cnt[S];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); ++S) &#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">OneCount</span>(S);</span><br><span class="line">    val[S] = <span class="built_in">min</span>(c, n - c); <span class="comment">// 正 vs 反</span></span><br><span class="line">    <span class="comment">// printf(&quot;%s: cnt = %lld, val = %lld\n&quot;, GetStr(S).c_str(), cnt[S], val[S]);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FwtXor</span>(cnt, n, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">FwtXor</span>(val, n, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); ++S) &#123;</span><br><span class="line">    cnt[S] = cnt[S] * val[S];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FwtXor</span>(cnt, n, <span class="literal">false</span>);</span><br><span class="line">  LL ans = cnt[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; n); ++S)</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, cnt[S]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式的一些实现细节</title>
      <link href="/2020-04-03-poly-about-some-details-in-coding/"/>
      <url>/2020-04-03-poly-about-some-details-in-coding/</url>
      
        <content type="html"><![CDATA[<p>标记一些易错的坑。</p><p>目前最新的模板以<strong>多项式开根</strong> <a href="../poly-sqrt-brief/">[Link↗]</a> 为准。</p><span id="more"></span><h1 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h1><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p>用法：<code>fill(begin_, end_, value)</code>。将 <code>[begin_, end_)</code> 中的内容赋值为 <code>value</code>。</p><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>用法：<code>copy(begin_, end_, target)</code> 将 <code>[begin_, end_)</code> 中的内容复制到 <code>target</code> 中。其中内容以 <code>target</code> 为起点开始排列。</p><h1 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h1><p>令 <code>lim = n &lt;&lt; 1</code>。</p><ol><li>清空<strong>输入</strong>数组（<code>a</code>）的 <code>[n, lim)</code> 区间</li><li>清空<strong>输出</strong>数组（<code>b</code>）的 <code>[0, lim)</code> 区间</li><li>清空<strong>临时</strong>数组（<code>tmp</code>）的 <code>[0, lim)</code> 区间</li></ol><h1 id="乘法留空间"><a href="#乘法留空间" class="headerlink" title="乘法留空间"></a>乘法留空间</h1><ol><li>若两个 $n$ 次多项式相乘，需要按照 $lim &#x3D; 2n$ 进行 FFT。</li><li>若需要用到输入的 <code>a</code> 做乘法，仅将需要的前 $n$ 位复制到临时数组 <code>tmp</code> 中，其余 <code>[n, lim)</code> 区间的系数丢掉。</li></ol><h1 id="总空间"><a href="#总空间" class="headerlink" title="总空间"></a>总空间</h1><p>目前已知：最少为 4 倍（补成 $2^k$ 两倍，乘法两倍）</p><p>稳妥的办法是开成 8 倍乃至 16 倍。在空间允许的范围内当然越稳越好。<strong>注意真正参与计算的多项式位数</strong>。有的题目可能要求构造一些多项式进行运算，这时多项式的位数不一定是 $n$ 位！</p>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式开根（简要笔记）</title>
      <link href="/2020-04-03-poly-sqrt-brief/"/>
      <url>/2020-04-03-poly-sqrt-brief/</url>
      
        <content type="html"><![CDATA[<p>对于 $A(x)$ 求一个 $B(x)$ 使得 $B(x) ^ 2 \equiv A(x) \pmod {x ^ n}$。</p><p>阅读这篇文章你需要</p><ol><li>多项式乘法</li><li>多项式求逆 <a href="../poly-inv-brief/">[Link↗]</a></li><li>牛顿迭代 <a href="../taylor-series-newton-iter-brief/">[Link↗]</a></li></ol><p>或者：</p><ol><li>多项式 Ln <a href="../poly-log-brief/">[Link↗]</a></li><li>多项式 Exp <a href="../poly-exp-brief/">[Link↗]</a></li></ol><span id="more"></span><h1 id="第一种方法：牛顿迭代"><a href="#第一种方法：牛顿迭代" class="headerlink" title="第一种方法：牛顿迭代"></a>第一种方法：牛顿迭代</h1><p>$$<br>\begin {split}<br>B(x) ^ 2 &amp;\equiv A(x) \pmod {x ^ n} \<br>B(x) ^ 2 - A(x) &amp;\equiv 0 \pmod {x ^ n}<br>\end {split}<br>$$</p><p>令 $F(B(x)) &#x3D; B(x) ^ 2 - A(x)$。</p><p>设 $F(B_0(x)) \equiv 0 \pmod {x ^ \frac {n} {2}}$，则：</p><p>$$<br>\begin {split}<br>B(x) &amp;\equiv B_0(x) - \frac {F(B_0(x))} {F’(B_0(x))} \<br>&amp;\equiv B_0(x) - \frac {B_0(x) ^ 2 - A(x)} {2B_0(x)} \<br>&amp;\equiv \frac {2B_0(x) ^ 2 - B_0(x) ^ 2 + A(x)} {2B_0(x)} \<br>&amp;\equiv \frac {B_0(x) ^ 2 + A(x)} {2B_0(x)} \<br>&amp;\equiv \frac {1} {2} \left ( B_0(x) + \frac {A(x)} {B_0(x)} \right ) \pmod {x ^ n} \<br>\end {split}<br>$$</p><p>代码参见 <code>GetSqrt</code> 函数。</p><h1 id="第二种方法：Ln-Exp"><a href="#第二种方法：Ln-Exp" class="headerlink" title="第二种方法：Ln + Exp"></a>第二种方法：Ln + Exp</h1><p>$$<br>\begin {split}<br>B(x) ^ 2 &amp;\equiv A(x) \pmod {x ^ n} \<br>2 \ln B(x) &amp;\equiv \ln A(x) \pmod {x ^ n} \<br>\ln B(x) &amp;\equiv \frac {\ln A(x)} {2} \pmod {x ^ n} \<br>B(x) &amp;\equiv \exp \left ( \frac {\ln A(x)} {2} \right ) \pmod {x ^ n}<br>\end {split}<br>$$</p><p>代码参见 <code>Sqrt</code> 函数。</p><h1 id="两种方法的比较"><a href="#两种方法的比较" class="headerlink" title="两种方法的比较"></a>两种方法的比较</h1><p>显然方法二更加简单，但速度更慢。</p><p>经测试第二种方法的耗时约为第一种方法的 2 倍。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">100000</span> * <span class="number">4</span> + <span class="number">10</span>; <span class="comment">// 开足空间！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kInv2 = <span class="number">499122177</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPri = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPriInv = <span class="number">332748118</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> get = <span class="built_in">getchar</span>();</span><br><span class="line">  LL res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(get)) get = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(get)) &#123;</span><br><span class="line">    res = res * <span class="number">10</span> + get - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    get = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fpow</span><span class="params">(LL x, LL k)</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans = ans * x % kMod;</span><br><span class="line">    x = x * x % kMod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fadd</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x += y) &gt;= kMod ? x - kMod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fdec</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + kMod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">RaderSort</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = (n &gt;&gt; <span class="number">1</span>); (j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Ntt</span><span class="params">(LL* a, <span class="type">int</span> n, <span class="type">bool</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RaderSort</span>(a, n);</span><br><span class="line">  LL pri = opt ? kPri : kPriInv;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    LL unit = <span class="built_in">Fpow</span>(pri, (kMod - <span class="number">1</span>) / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">      LL w = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> mid = i + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (len &gt;&gt; <span class="number">1</span>); ++j) &#123;</span><br><span class="line">        LL tmp = w * a[mid + j] % kMod;</span><br><span class="line">        a[mid + j] = <span class="built_in">Fdec</span>(a[i + j], tmp);</span><br><span class="line">        a[i + j] = <span class="built_in">Fadd</span>(a[i + j], tmp);</span><br><span class="line">        w = w * unit % kMod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">    LL inv = <span class="built_in">Fpow</span>(n, kMod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      a[i] = a[i] * inv % kMod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetInvIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> LL tmp[kMaxN];</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(tmp, tmp + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(a, a + n, tmp);</span><br><span class="line">  <span class="built_in">Ntt</span>(tmp, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = <span class="built_in">Fdec</span>(<span class="number">2</span>, tmp[i] * b[i] % kMod) * b[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">fill</span>(b + n, b + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetInv</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">fill</span>(b, b + lim, <span class="number">0</span>);</span><br><span class="line">  b[<span class="number">0</span>] = <span class="built_in">Fpow</span>(a[<span class="number">0</span>], kMod - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">GetInvIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Deri</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    a[i] = (i + <span class="number">1</span>) * a[i + <span class="number">1</span>] % kMod;</span><br><span class="line">  a[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inte</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    a[i + <span class="number">1</span>] = a[i] * <span class="built_in">Fpow</span>(i + <span class="number">1</span>, kMod - <span class="number">2</span>) % kMod;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Log</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> LL tmp[kMaxN];</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">fill</span>(tmp, tmp + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">GetInv</span>(a, tmp, n);</span><br><span class="line">  <span class="built_in">Deri</span>(a, n);</span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(tmp, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    a[i] = a[i] * tmp[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">Inte</span>(a, n);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetExpIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> LL tmp[kMaxN]; <span class="comment">// 总要记得清空临时数组！</span></span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(tmp, tmp + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(b, b + n, tmp);</span><br><span class="line">  <span class="built_in">Log</span>(tmp, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    tmp[i] = <span class="built_in">Fdec</span>(a[i], tmp[i]);</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(tmp, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = b[i] * (tmp[i] + <span class="number">1</span>) % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetExp</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">fill</span>(b, b + lim, <span class="number">0</span>); <span class="comment">// 总要记得清空输出数组！</span></span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// a[0] = 0, b[0] = e ^ a[0] = e ^ 0 = 1.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">GetExpIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetSqrtIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> LL tmp_a[kMaxN], tmp_b[kMaxN];</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(tmp_a, tmp_a + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">fill</span>(tmp_b, tmp_b + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">GetInv</span>(b, tmp_b, n);</span><br><span class="line">  <span class="built_in">copy</span>(a, a + n, tmp_a);</span><br><span class="line">  <span class="built_in">Ntt</span>(tmp_a, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(tmp_b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    tmp_a[i] = tmp_a[i] * tmp_b[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(tmp_a, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = (b[i] + tmp_a[i]) % kMod * kInv2 % kMod;</span><br><span class="line">  <span class="built_in">fill</span>(b + n, b + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetSqrt</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">fill</span>(b, b + lim, <span class="number">0</span>); <span class="comment">// 清空输出的 b 数组</span></span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 保证 a[0] = 1</span></span><br><span class="line">  <span class="comment">// 若 a[0] != 1，则需要二次剩余模板</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">GetSqrtIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Sqrt</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> LL tmp[kMaxN];</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(tmp, tmp + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(a, a + n, tmp);</span><br><span class="line">  <span class="built_in">Log</span>(tmp, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    tmp[i] = tmp[i] * kInv2 % kMod;</span><br><span class="line">  <span class="built_in">GetExp</span>(tmp, a, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, lim;</span><br><span class="line">LL a[kMaxN], b[kMaxN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">Read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    a[i] = <span class="built_in">Read</span>();</span><br><span class="line">  lim = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (lim &lt; n) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Sqrt</span>(a, lim); <span class="comment">// OR: GetSqrt(a, b, lim);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, a[i]); <span class="comment">// OR: printf(&quot;%lld &quot;, b[i]);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P4705 玩游戏（简要笔记）</title>
      <link href="/2020-04-01-sol-luogu-P4705-brief/"/>
      <url>/2020-04-01-sol-luogu-P4705-brief/</url>
      
        <content type="html"><![CDATA[<p>入门稍进阶，挺有意思的一道题。</p><p>阅读这篇文章你需要：</p><ol><li><del>待填坑</del> &#x2F;kel</li></ol><p>题面见链接 <a href="https://www.luogu.com.cn/problem/P4705">[Link↗]</a></p><span id="more"></span><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h1 id="推导-I"><a href="#推导-I" class="headerlink" title="推导 I"></a>推导 I</h1><p>记“$k$ 次价值”的答案为 $c _ k$。根据期望的定义得到式子：</p><p>$$<br>c _ k &#x3D; \sum _ {x &#x3D; 0} ^ {n - 1} \sum _ {y &#x3D; 0} ^ {m - 1} (a _ x + b _ y) ^ k \cdot \frac {1} {nm}<br>$$</p><p>进行推导。</p><p>$$<br>\begin {split}<br>c _ k &amp;&#x3D; \sum _ {x &#x3D; 0} ^ {n - 1} \sum _ {y &#x3D; 0} ^ {m - 1} (a _ x + b _ y) ^ k \cdot \frac {1} {nm} \<br>&amp;&#x3D; \sum _ {x &#x3D; 0} ^ {n - 1} \sum _ {y &#x3D; 0} ^ {m - 1} \sum _ {i + j &#x3D; k} \binom {k} {i} a _ x ^ i b _ y ^ j \cdot \frac {1} {nm} \<br>&amp;&#x3D; \sum _ {i + j &#x3D; k} \sum _ {x &#x3D; 0} ^ {n - 1} \sum _ {y &#x3D; 0} ^ {m - 1} \binom {k} {i} a _ x ^ i b _ y ^ j \cdot \frac {1} {nm} \<br>&amp;&#x3D; \frac {1} {nm} \sum _ {i + j &#x3D; k} \binom {k} {i} \sum _ {x &#x3D; 0} ^ {n - 1} a _ x ^ i \sum _ {y &#x3D; 0} ^ {m - 1} b _ y ^ j \<br>&amp;&#x3D; \frac {1} {nm} \sum _ {i + j &#x3D; k} \frac {k!} {i! j!} \sum _ {x &#x3D; 0} ^ {n - 1} a _ x ^ i \sum _ {y &#x3D; 0} ^ {m - 1} b _ y ^ j \<br>&amp;&#x3D; \frac {k!} {nm} \sum _ {i + j &#x3D; k} \frac {1} {i!} \sum _ {x &#x3D; 0} ^ {n - 1} a _ x ^ i \frac {1} {j!} \sum _ {y &#x3D; 0} ^ {m - 1} b _ y ^ j \<br>&amp;&#x3D; \frac {k!} {nm} \sum _ {i + j &#x3D; k} \left ( \frac {1} {i!} \sum _ {x &#x3D; 0} ^ {n - 1} a _ x ^ i \right ) \left ( \frac {1} {j!} \sum _ {y &#x3D; 0} ^ {m - 1} b _ y ^ j \right ) \<br>&amp;&#x3D; \frac {k!} {nm} \sum _ {i + j &#x3D; k} \left ( \frac {1} {i!} a’ _ i \right ) \left ( \frac {1} {j!} b’ _ j \right )<br>\end {split}<br>$$</p><p>看得出这是一个卷积的形式。其中相乘的两项分别为 $\left &lt; \frac {1} {i!} a’ _ i \right &gt;$ 和 $\left &lt; \frac {1} {j!} b’ _ j \right &gt;$。（这里 $\left &lt; x \right &gt;$ 表示序列）</p><p>考虑怎么求 $\displaystyle a’ _ i &#x3D; \sum _ {x &#x3D; 0} ^ {n - 1} a _ x ^ i$。</p><h1 id="推导-II"><a href="#推导-II" class="headerlink" title="推导 II"></a>推导 II</h1><p>不妨利用生成函数的数学工具。</p><p>将需要求解的序列放入生成函数，并利用其性质对式子进行变换，从而得到<strong>快速求解系数</strong>的算法。此时我们就可以使用 FFT 等算法进行计算。</p><p>设 $\left &lt; a’ _ i \right &gt;$ 的生成函数为 $A(X)$，那么：</p><p>$$<br>\begin {split}<br>A(X) &amp;&#x3D; \sum _ {i &#x3D; 0} ^ {\infty} a’ _ i X ^ i \<br>&amp;&#x3D; \sum _ {i &#x3D; 0} ^ {\infty} \sum _ {x &#x3D; 0} ^ {n - 1} a _ x ^ i X ^ i \<br>&amp;&#x3D; \sum _ {x &#x3D; 0} ^ {n - 1} \sum _ {i &#x3D; 0} ^ {\infty} a _ x ^ i X ^ i \<br>&amp;&#x3D; \sum _ {x &#x3D; 0} ^ {n - 1} \frac {1} {1 - a _ x X}<br>\end {split}<br>$$</p><p>不妨记作 $\displaystyle A(x) &#x3D; \sum _ {i &#x3D; 0} ^ {n - 1} \frac {1} {1 - a _ i x}$。</p><p><strong>（最关键也是最困难的一步）</strong>考虑：</p><p>$$<br>\begin {split}<br>\ln’ (1 - a _ i x) &amp;&#x3D; \frac {1} {1 - a _ i x} &#x3D; F \<br>(\ln (1 - a _ i x))’ &amp;&#x3D; \frac {-a _ i} {1 - a _ i x} &#x3D; G<br>\end {split}<br>$$</p><p>则 $F + x \cdot G &#x3D; 1$。即 $F &#x3D; 1 - x \cdot G$。</p><blockquote><p>  容易陷入的一个误区：用 $F &#x3D; \frac {G} {-a _ i}$ 来表示 $F$。</p><p>  理论上这是可行的。然而将其代入式子 $\sum _ {i &#x3D; 0} ^ {n - 1} F$ 中，就会发现这对解题没有任何帮助。</p><p>  正确的方法应该要让 $F$ 和 $G$ 之间不与 $i$ 发生任何关系，从而提取因式实现 $F$ 到 $G$ 的转换。</p></blockquote><p>$$<br>\begin {split}<br>A(x) &amp;&#x3D; \sum _ {i &#x3D; 0} ^ {n - 1} \frac {1} {1 - a _ i x} \<br>&amp;&#x3D; \sum _ {i &#x3D; 0} ^ {n - 1} \ln’ (1 - a _ i x) \<br>&amp;&#x3D; \sum _ {i &#x3D; 0} ^ {n - 1} (1 - x \cdot (\ln (1 - a _ i x))’) \<br>&amp;&#x3D; \sum _ {i &#x3D; 0} ^ {n - 1} 1 - \sum _ {i &#x3D; 0} ^ {n - 1} x \cdot (\ln (1 - a _ i x))’ \<br>&amp;&#x3D; n - x \sum _ {i &#x3D; 0} ^ {n - 1} (\ln (1 - a _ i x))’<br>\end {split}<br>$$</p><p>考虑计算 $\displaystyle \sum _ {i &#x3D; 0} ^ {n - 1} (\ln (1 - a _ i x))’$。</p><h1 id="推导-III"><a href="#推导-III" class="headerlink" title="推导 III"></a>推导 III</h1><p>运用套路：$\displaystyle \sum \ln (\text {xxx}) \iff \ln \prod (\text {xxx})$。参考<strong>付公主的背包</strong>一题对这个方法的运用 <a href="../sol-luogu-P4389/#%E5%B9%B2%E5%98%9B%E8%A6%81%E7%9B%B8%E4%B9%98">[Link↗]</a>。</p><p>$$<br>\begin {split}<br>\sum _ {i &#x3D; 0} ^ {n - 1} (\ln (1 - a _ i x))’ &amp;&#x3D; \left ( \sum _ {i &#x3D; 0} ^ {n - 1} \ln (1 - a _ i x) \right )’ \<br>&amp;&#x3D; \left ( \ln \prod _ {i &#x3D; 0} ^ {n - 1} (1 - a _ i x) \right )’<br>\end {split}<br>$$</p><p>有一个经典的分治算法可以解决 $\prod _ {i &#x3D; 0} ^ {n - 1} (1 - a _ i x)$。具体来说，若 $n$ 是 $2$ 的 $k$ 次幂，令 $m &#x3D; \frac {n} {2}$，将式子拆成 $\prod _ {i &#x3D; 0} ^ {m - 1} (1 - a _ i x)$ 和 $\prod _ {i &#x3D; m} ^ {n - 1} (1 - a _ i x)$ 两部分递归求解。回溯时将这两部分用 FFT 乘起来即可。</p><h1 id="归纳算法流程"><a href="#归纳算法流程" class="headerlink" title="归纳算法流程"></a>归纳算法流程</h1><p>整理一下我们需要做什么：</p><ol><li>递归求 $\prod _ {i &#x3D; 0} ^ {n - 1} (1 - a _ i x)$。</li><li>多项式 Ln，得到 $\ln \prod _ {i &#x3D; 0} ^ {n - 1} (1 - a _ i x)$。</li><li>求导，得到 $\left ( \ln \prod _ {i &#x3D; 0} ^ {n - 1} (1 - a _ i x) \right )’$</li><li>用 $F &#x3D; 1 - x \cdot G$ 得到 $n - x \cdot \left ( \ln \prod _ {i &#x3D; 0} ^ {n - 1} (1 - a _ i x) \right )’$。即为 $a _ i’$ 的生成函数 $A(x)$。</li><li>将所有 $a _ i’$ 乘上 $\frac {1} {i!}$。求 $a _ i’$ 和 $b _ i’$ 的卷积。答案乘以 $\frac {k!} {nm}$。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">100000</span> * <span class="number">16</span> + <span class="number">10</span>; <span class="comment">// 开足空间！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPri = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPriInv = <span class="number">332748118</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> get = <span class="built_in">getchar</span>();</span><br><span class="line">  LL res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(get)) get = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(get)) &#123;</span><br><span class="line">    res = res * <span class="number">10</span> + get - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    get = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fpow</span><span class="params">(LL x, LL k)</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans = ans * x % kMod;</span><br><span class="line">    x = x * x % kMod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fadd</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x += y) &gt;= kMod ? x - kMod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fdec</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + kMod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">RaderSort</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = (n &gt;&gt; <span class="number">1</span>); (j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Ntt</span><span class="params">(LL* a, <span class="type">int</span> n, <span class="type">bool</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RaderSort</span>(a, n);</span><br><span class="line">  LL pri = opt ? kPri : kPriInv;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    LL unit = <span class="built_in">Fpow</span>(pri, (kMod - <span class="number">1</span>) / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">      LL w = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> mid = i + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (len &gt;&gt; <span class="number">1</span>); ++j) &#123;</span><br><span class="line">        LL tmp = w * a[mid + j] % kMod;</span><br><span class="line">        a[mid + j] = <span class="built_in">Fdec</span>(a[i + j], tmp);</span><br><span class="line">        a[i + j] = <span class="built_in">Fadd</span>(a[i + j], tmp);</span><br><span class="line">        w = w * unit % kMod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">    LL inv = <span class="built_in">Fpow</span>(n, kMod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      a[i] = a[i] * inv % kMod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="type">inv_t</span>[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">InvIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">inv_t</span>, <span class="type">inv_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(a, a + n, <span class="type">inv_t</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">inv_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = <span class="built_in">Fdec</span>(<span class="number">2</span>, <span class="type">inv_t</span>[i] * b[i] % kMod) * b[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">fill</span>(b + n, b + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inv</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(b, b + n, <span class="number">0</span>);</span><br><span class="line">  b[<span class="number">0</span>] = <span class="built_in">Fpow</span>(a[<span class="number">0</span>], kMod - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">InvIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Deri</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    a[i] = (i + <span class="number">1</span>) * a[i + <span class="number">1</span>] % kMod;</span><br><span class="line">  a[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inte</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    a[i + <span class="number">1</span>] = a[i] * <span class="built_in">Fpow</span>(i + <span class="number">1</span>, kMod - <span class="number">2</span>) % kMod;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="type">log_t</span>[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Log</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">log_t</span>, <span class="type">log_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Inv</span>(a, <span class="type">log_t</span>, n);</span><br><span class="line">  <span class="built_in">Deri</span>(a, lim);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">log_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    a[i] = a[i] * <span class="type">log_t</span>[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">Inte</span>(a, n);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="type">exp_t</span>[kMaxN], exp_a[kMaxN]; <span class="comment">// 总要记得清空临时数组！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ExpIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">exp_t</span>, <span class="type">exp_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(b, b + n, <span class="type">exp_t</span>);</span><br><span class="line">  <span class="built_in">Log</span>(<span class="type">exp_t</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="type">exp_t</span>[i] = <span class="built_in">Fdec</span>(a[i], <span class="type">exp_t</span>[i]);</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">exp_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = b[i] * (<span class="type">exp_t</span>[i] + <span class="number">1</span>) % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Exp</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(b, b + n, <span class="number">0</span>); <span class="comment">// 总要记得清空输出数组！</span></span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// a[0] = 0, b[0] = e ^ a[0] = e ^ 0 = 1.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">ExpIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// res = (1 - a_0 x) (1 - a_1 x) (1 - a_2 x) ... (1 - a_&#123;n - 1&#125; x)</span></span><br><span class="line"><span class="comment">// res 的长度预留 4 倍（乘法留空间△）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(LL* a, LL* res, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">1</span>] = kMod - a[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">2</span>] = res[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid = (n &gt;&gt; <span class="number">1</span>), lim = mid * <span class="number">4</span>; <span class="comment">// lim 即为留空间</span></span><br><span class="line">    <span class="built_in">Solve</span>(a, res, mid);</span><br><span class="line">    <span class="built_in">Solve</span>(a + mid, res + lim, mid);</span><br><span class="line">    <span class="built_in">Ntt</span>(res, lim, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">Ntt</span>(res + lim, lim, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">      res[i] = res[i] * res[lim + i] % kMod;</span><br><span class="line">    <span class="built_in">Ntt</span>(res, lim, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">fill</span>(res + lim, res + <span class="number">2</span> * lim, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m, t, lim;</span><br><span class="line">LL a0[kMaxN], b0[kMaxN];</span><br><span class="line">LL a[kMaxN], b[kMaxN];</span><br><span class="line">LL fac[kMaxN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Calc</span><span class="params">(LL* a0, LL* a, <span class="type">int</span> lim, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>(a0, a, lim);</span><br><span class="line">  <span class="built_in">Log</span>(a, lim);</span><br><span class="line">  <span class="built_in">Deri</span>(a, lim);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = lim - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    a[i] = kMod - a[i - <span class="number">1</span>];</span><br><span class="line">  a[<span class="number">0</span>] = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    a[i] = a[i] * <span class="built_in">Fpow</span>(fac[i], kMod - <span class="number">2</span>) % kMod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a0[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b0[i]);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="type">int</span> maxn = <span class="built_in">max</span>(<span class="built_in">max</span>(n, m), t) + <span class="number">10</span>;</span><br><span class="line">  lim = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (lim &lt; maxn) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">    fac[i] = fac[i - <span class="number">1</span>] * i % kMod;</span><br><span class="line">  <span class="built_in">Calc</span>(a0, a, lim, n);</span><br><span class="line">  <span class="built_in">Calc</span>(b0, b, lim, m);</span><br><span class="line">  <span class="built_in">Ntt</span>(a, (lim &lt;&lt; <span class="number">1</span>), <span class="literal">true</span>); <span class="comment">// 留空间！！！！！！！！</span></span><br><span class="line">  <span class="built_in">Ntt</span>(b, (lim &lt;&lt; <span class="number">1</span>), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (lim &lt;&lt; <span class="number">1</span>); ++i)</span><br><span class="line">    a[i] = a[i] * b[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(a, (lim &lt;&lt; <span class="number">1</span>), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, a[i] * <span class="built_in">Fpow</span>(<span class="number">1ll</span> * n * m % kMod, kMod - <span class="number">2</span>) % kMod * fac[i] % kMod);</span><br><span class="line">  <span class="comment">// 请注意这个 1ll * n * m！！！！！！！！</span></span><br><span class="line">  <span class="comment">// 类型强制转换！！！！！</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 luogu P3175 [HAOI2015]按位或</title>
      <link href="/2020-03-31-sol-luogu-P3175/"/>
      <url>/2020-03-31-sol-luogu-P3175/</url>
      
        <content type="html"><![CDATA[<p>阅读这篇文章你需要</p><ol><li>min-max 容斥定理（最值反演）</li></ol><p>题面见链接 <a href="https://www.luogu.com.cn/problem/P3175">[Link↗]</a></p><span id="more"></span><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ol><li><p>min-max 容斥定理：$\max (S) &#x3D; \displaystyle \sum _ {T \subseteq S} (-1) ^ {|T| - 1} \min (T)$</p><p>该定理在期望意义下同样成立：</p><p>$E(\max (S)) &#x3D; \displaystyle \sum _ {T \subseteq S} (-1) ^ {|T| - 1} E(\min (T))$</p></li><li><p>离散随机变量的几何分布</p><p>其实就是一个很简单的结论：若对于随机变量 $X$ 满足 $P(X &#x3D; k) &#x3D; (1 - p) ^ {k - 1} p$，则 $E(X) &#x3D; \dfrac {1} {p}$</p><p>感性理解：你要去膜拜 <strong>yyc</strong>，每次膜拜有 $\dfrac {1} {100}$ 的概率能够被 yyc 不屑看上一眼（从而得到 yyc 神犇光环庇佑），则第 $k$ 次膜拜才第一次被 yyc 看上一眼的概率是：</p><p>$$<br>(1 - \dfrac {1} {100}) ^ {k - 1} \dfrac {1} {100}<br>$$</p><p>而期望 $100$ 次才第一次被 yyc 看上一眼。同样地，假如概率是 $\dfrac {1} {1000}$，则期望次数是 $1000$ 次；假如概率是 $\dfrac {a} {b}$，则期望次数是 $\dfrac {b} {a}$ 次……依此类推。</p></li></ol><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>下文 $n$ 表示二进制串的长度，$U$ 表示全集。</p><p>假设<strong>某次所有操作结束</strong>，你手上的数字变成 $2 ^ n - 1$ 之后，我们统计操作过程时发现第 $i$ 位在第 $k _ i$ 次操作的时候，刚好第一次变成 $1$（“被覆盖”）。</p><p>若 $S$ 表示一些二进制位的集合。记 $\max (S)$ 表示 $\max ({ k _ i | i \in S })$，即 $S$ 中最后一个被覆盖的位在这次操作中喜提 $0$ 转 $1$。显然 $\max (S)$ 就是 $S$ 被最终整个覆盖的时间。同理定义 $\min(S)$，则 $\min(S)$ 表示 $S$ 第一次被覆盖某个位的时间。</p><p>好好理解 $\min(S)$ 和 $\max(S)$ 的含义。根据 min-max 容斥定理，就可以得到</p><p>$$<br>\max(S) &#x3D; \displaystyle \sum _ {T \subseteq S} (-1) ^ {|T| - 1} \min(T)<br>$$</p><p>放到期望意义下，“某次所有操作结束”变成“总的来说……平均起来”</p><p>$$<br>E(\max(S)) &#x3D; \displaystyle \sum _ {T \subseteq S} (-1) ^ {|T| - 1} E(\min(T))<br>$$</p><p>请看这条式子的左边：$E(\max(S))$ 正是将 $S$ 整个覆盖的期望秒数。</p><p>那么答案就是 $E(\max(U))$。既然 $E(\max(S))$ 不好求（不然也不会出题让我们做 &#x3D; &#x3D;），我们就想办法求出 $E(\min(T))$。</p><h1 id="求-E-min-T"><a href="#求-E-min-T" class="headerlink" title="求 E(min(T))"></a>求 E(min(T))</h1><p>记 $p(S)$ 表示选择 $S$ 的概率，即题目输入。</p><p>$E(\min(T))$ 表示第一次覆盖 $T$ 中任一元素的期望操作次数。</p><p>设 $P(T)$ 表示一次操作能覆盖 $T$ 中任一元素的概率。</p><p>则</p><p>$$<br>E(\min(T)) &#x3D; \dfrac {1} {P(T)}<br>$$</p><p>加法原理</p><p>$$<br>P(T) &#x3D; \displaystyle \sum _ {S \cap T \not &#x3D; \varnothing} p(S)<br>     &#x3D; 1 - \displaystyle \sum _ {S \cap T &#x3D; \varnothing} p(S)<br>     &#x3D; 1 - \displaystyle \sum _ {S \subseteq (U - T)} p(S)<br>$$</p><p>记 $P’(T) &#x3D; \displaystyle \sum _ {S \subseteq T} p(S)$，则 $P(T) &#x3D; 1 - P’(U - T)$。</p><p>用<strong>高维前缀和</strong> <a href="../math-notes/#note-1">[Link↗]</a> 求 $P’(T)$。它是 $p(S)$ 的高维前缀和。</p><p>求出 $P’(T)$ 后求 $P(T)$，求 $\min(T)$，最后得到 $\max(S)$。输出 $\max(U)$。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>特判 $\min(\varnothing)$，令其等于 $0$ 以不干扰计算（不然会算出 $\inf$）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kLen = <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = (<span class="number">1</span> &lt;&lt; kLen) + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> kEps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SubSum</span><span class="params">(<span class="type">double</span>* a, <span class="type">int</span> blen)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; blen; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">        a[i] += a[i ^ (<span class="number">1</span> &lt;&lt; k)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SubMul</span><span class="params">(<span class="type">double</span>* a, <span class="type">int</span> blen)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; blen; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">        a[i] *= a[i ^ (<span class="number">1</span> &lt;&lt; k)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> blen, n, U;</span><br><span class="line"><span class="type">double</span> p1[kMaxN], p2[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PrintBit</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> blen)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; blen; ++k)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (S &amp; (<span class="number">1</span> &lt;&lt; k)) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">double</span>* a, <span class="type">int</span> blen)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;print:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; (<span class="number">1</span> &lt;&lt; blen); ++S) &#123;</span><br><span class="line">    <span class="built_in">PrintBit</span>(S, blen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;: %.3lf\n&quot;</span>, a[S]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Cnt</span><span class="params">(<span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; S; S -= (S &amp; -S)) ++ans;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;blen);</span><br><span class="line">  n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  U = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; n; ++S)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p1[S]);</span><br><span class="line">  <span class="built_in">SubSum</span>(p1, blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; n; ++S)</span><br><span class="line">    p2[S] = p1[U - S];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; n; ++S) &#123;</span><br><span class="line">    <span class="keyword">if</span> (S != <span class="number">0</span> &amp;&amp; <span class="number">1</span> - p2[S] &lt; kEps) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;INF\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p2[S] = <span class="number">1.0</span> / (<span class="number">1</span> - p2[S]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> S = <span class="number">0</span>; S &lt; n; ++S)</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">Cnt</span>(S) &amp; <span class="number">1</span>))</span><br><span class="line">      p2[S] = -p2[S];</span><br><span class="line">  p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">SubSum</span>(p2, blen);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, p2[U]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式 Exp（简要笔记）</title>
      <link href="/2020-03-31-poly-exp-brief/"/>
      <url>/2020-03-31-poly-exp-brief/</url>
      
        <content type="html"><![CDATA[<p>求 $B(x) \equiv e ^ {A(x)} \pmod {x ^ n}$</p><p>阅读这篇文章你需要</p><ol><li>多项式乘法</li><li>多项式求逆 <a href="../poly-inv-brief/">[Link↗]</a></li><li>多项式 Ln 函数 <a href="../poly-log-brief/">[Link↗]</a></li><li>牛顿迭代 <a href="../taylor-series-newton-iter-brief/">[Link↗]</a></li></ol><span id="more"></span><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>求导 <a href="../math-notes/#note-2-6">[Link↗]</a></li></ul><h1 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h1><p>若 $B(x) \equiv e ^ {A(x)} \pmod {x ^ n}$</p><p>则 $\ln B(x) \equiv A(x) \pmod {x ^ n}$，即 $\ln B(x) - A(x) \equiv 0 \pmod {x ^ n}$。</p><p>令 $F(B(x) &#x3D; \ln B(x) - A(x)$，则 $F(B(x)) \equiv 0 \pmod {x ^ n}$。</p><p><strong>注意</strong>：这里 $F(B)$ 表示“以 $B$ 为自变量的函数”，故 $F’(B(x)) &#x3D; \dfrac {1} {B(x)}$。参见 <a href="../math-notes/#note-2-6">[Link↗]</a>。</p><p>设 $F(B _ 0(x)) \equiv 0 \pmod {x ^ \frac n 2}$，则</p><p>$$<br>\begin {split}<br>    B(x) &amp; \equiv B _ 0(x) - \dfrac {F(B _ 0(x))} {F’(B _ 0(x))} \pmod {x ^ n} \<br>         &amp; \equiv B _ 0(x) - \dfrac {\ln B _ 0(x) - A(x)} {\left ( \dfrac {1} {B _ 0(x)} \right )} \pmod {x ^ n} \<br>         &amp; \equiv B _ 0(x) - B _ 0(x) (\ln B _ 0(x) - A(x)) \pmod {x ^ n} \<br>         &amp; \equiv B _ 0(x) (1 - \ln B _ 0(x) + A(x))<br>\end {split}<br>$$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LL <span class="type">exp_t</span>[kMaxN], exp_a[kMaxN]; <span class="comment">// 总要记得清空临时数组！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ExpIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>); <span class="comment">// 乘法：保留空间 (1)</span></span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">exp_t</span>, <span class="type">exp_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(b, b + n, <span class="type">exp_t</span>); <span class="comment">// 乘法：保留空间 (2)</span></span><br><span class="line">  <span class="built_in">Log</span>(<span class="type">exp_t</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="type">exp_t</span>[i] = <span class="built_in">Fdec</span>(a[i], <span class="type">exp_t</span>[i]); <span class="comment">// 求 ln B0(x) + A(x)，降低常数</span></span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">exp_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = b[i] * (<span class="type">exp_t</span>[i] + <span class="number">1</span>) % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Exp</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(b, b + n, <span class="number">0</span>); <span class="comment">// 总要记得清空输出数组！</span></span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// a[0] = 0, b[0] = e ^ a[0] = e ^ 0 = 1.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">ExpIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题代码"><a href="#例题代码" class="headerlink" title="例题代码"></a>例题代码</h1><p>luogu P4389 付公主的背包 <a href="https://www.luogu.com.cn/problem/P4389">[Link↗]</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">100000</span> * <span class="number">8</span> + <span class="number">10</span>; <span class="comment">// 开足空间！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPri = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPriInv = <span class="number">332748118</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> get = <span class="built_in">getchar</span>();</span><br><span class="line">  LL res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(get)) get = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(get)) &#123;</span><br><span class="line">    res = res * <span class="number">10</span> + get - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    get = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fpow</span><span class="params">(LL x, LL k)</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans = ans * x % kMod;</span><br><span class="line">    x = x * x % kMod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fadd</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x += y) &gt;= kMod ? x - kMod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fdec</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + kMod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">RaderSort</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = (n &gt;&gt; <span class="number">1</span>); (j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Ntt</span><span class="params">(LL* a, <span class="type">int</span> n, <span class="type">bool</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RaderSort</span>(a, n);</span><br><span class="line">  LL pri = opt ? kPri : kPriInv;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    LL unit = <span class="built_in">Fpow</span>(pri, (kMod - <span class="number">1</span>) / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">      LL w = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> mid = i + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (len &gt;&gt; <span class="number">1</span>); ++j) &#123;</span><br><span class="line">        LL tmp = w * a[mid + j] % kMod;</span><br><span class="line">        a[mid + j] = <span class="built_in">Fdec</span>(a[i + j], tmp);</span><br><span class="line">        a[i + j] = <span class="built_in">Fadd</span>(a[i + j], tmp);</span><br><span class="line">        w = w * unit % kMod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">    LL inv = <span class="built_in">Fpow</span>(n, kMod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      a[i] = a[i] * inv % kMod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="type">inv_t</span>[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">InvIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">inv_t</span>, <span class="type">inv_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(a, a + n, <span class="type">inv_t</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">inv_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = <span class="built_in">Fdec</span>(<span class="number">2</span>, <span class="type">inv_t</span>[i] * b[i] % kMod) * b[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">fill</span>(b + n, b + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inv</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(b, b + n, <span class="number">0</span>);</span><br><span class="line">  b[<span class="number">0</span>] = <span class="built_in">Fpow</span>(a[<span class="number">0</span>], kMod - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">InvIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Deri</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    a[i] = (i + <span class="number">1</span>) * a[i + <span class="number">1</span>] % kMod;</span><br><span class="line">  a[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inte</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    a[i + <span class="number">1</span>] = a[i] * <span class="built_in">Fpow</span>(i + <span class="number">1</span>, kMod - <span class="number">2</span>) % kMod;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="type">log_t</span>[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Log</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">log_t</span>, <span class="type">log_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Inv</span>(a, <span class="type">log_t</span>, n);</span><br><span class="line">  <span class="built_in">Deri</span>(a, lim);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">log_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    a[i] = a[i] * <span class="type">log_t</span>[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">Inte</span>(a, n);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="type">exp_t</span>[kMaxN], exp_a[kMaxN]; <span class="comment">// 总要记得清空临时数组！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ExpIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">exp_t</span>, <span class="type">exp_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(b, b + n, <span class="type">exp_t</span>);</span><br><span class="line">  <span class="built_in">Log</span>(<span class="type">exp_t</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="type">exp_t</span>[i] = <span class="built_in">Fdec</span>(a[i], <span class="type">exp_t</span>[i]);</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">exp_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = b[i] * (<span class="type">exp_t</span>[i] + <span class="number">1</span>) % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Exp</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(b, b + n, <span class="number">0</span>); <span class="comment">// 总要记得清空输出数组！</span></span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// a[0] = 0, b[0] = e ^ a[0] = e ^ 0 = 1.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">ExpIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n：商品数</span></span><br><span class="line"><span class="comment">// m：输出的数量</span></span><br><span class="line"><span class="type">int</span> n, m, lim;</span><br><span class="line">LL v[kMaxN];</span><br><span class="line">LL cnt[kMaxN];</span><br><span class="line">LL a[kMaxN], b[kMaxN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">Read</span>(), m = <span class="built_in">Read</span>();</span><br><span class="line">  <span class="comment">// ++m; // 注意：输出时要用 [1, m]！</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    v[i] = <span class="built_in">Read</span>();</span><br><span class="line">    ++cnt[v[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// O(mlogm)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= m; j += i) &#123;</span><br><span class="line">        ++cur;</span><br><span class="line">        a[j] = (a[j] + <span class="built_in">Fpow</span>(cur, kMod - <span class="number">2</span>) * cnt[i] % kMod) % kMod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lim = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (lim &lt; m + <span class="number">10</span>) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// for (int i = 0; i &lt; lim; ++i)</span></span><br><span class="line">  <span class="comment">//   printf(&quot;%lld &quot;, a[i]);</span></span><br><span class="line">  <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">  <span class="built_in">Exp</span>(a, b, lim);</span><br><span class="line">  <span class="comment">// for (int i = 0; i &lt; lim; ++i)</span></span><br><span class="line">  <span class="comment">//   printf(&quot;%lld &quot;, b[i]);</span></span><br><span class="line">  <span class="comment">// printf(&quot;\n[Debug end]\n&quot;);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, b[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式 Ln 函数（简要笔记）</title>
      <link href="/2020-03-31-poly-log-brief/"/>
      <url>/2020-03-31-poly-log-brief/</url>
      
        <content type="html"><![CDATA[<p>求 $B(x) \equiv \ln A(x) \pmod {x ^ n}$</p><p>阅读这篇文章你需要</p><ol><li>多项式乘法</li><li>多项式求逆 <a href="../poly-inv-brief/">[Link↗]</a></li></ol><span id="more"></span><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>求导 <a href="../math-notes/#note-4-6">[Link↗]</a></li></ul><h1 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h1><p>$$<br>\begin {split}<br>     B(x) &amp; \equiv \ln A(x) \pmod {x ^ n} \<br>    B’(x) &amp; \equiv \dfrac {A’(x)} {A(x)} \pmod {x ^ n} \<br>     B(x) &amp; \equiv \int \dfrac {A’(x)} {A(x)} \pmod {x ^ n} \<br>\end {split}<br>$$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>“一元函数”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LL <span class="type">log_t</span>[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Log</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>); <span class="comment">// 乘法：保留空间 (1)</span></span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">log_t</span>, <span class="type">log_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Inv</span>(a, <span class="type">log_t</span>, n); <span class="comment">// 令 log_t = 1 / a</span></span><br><span class="line">  <span class="built_in">Deri</span>(a, lim);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>); <span class="comment">// 乘法：保留空间 (2)</span></span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">log_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    a[i] = a[i] * <span class="type">log_t</span>[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">Inte</span>(a, n);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 luogu P4389 付公主的背包</title>
      <link href="/2020-03-29-sol-luogu-P4389/"/>
      <url>/2020-03-29-sol-luogu-P4389/</url>
      
        <content type="html"><![CDATA[<p>生成函数经典入门题！</p><p>阅读这篇文章你需要：</p><ol><li>完成多项式 Ln、Exp 模板</li><li>最基础的生成函数知识</li></ol><p>题面见链接 <a href="https://www.luogu.com.cn/problem/P4389">[Link↗]</a></p><span id="more"></span><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ol><li>$\displaystyle \sum _ {i &#x3D; 0} ^ {\infty} x ^ i &#x3D; \dfrac {1} {1 - x}$ <a href="../math-notes/#note-3">[Link↗]</a></li></ol><h1 id="当-n-2-时……"><a href="#当-n-2-时……" class="headerlink" title="当 n &#x3D; 2 时……"></a>当 n &#x3D; 2 时……</h1><p>设 $A[i]$ 表示仅用第一种物品装满 $i$ 体积的方案数，显然 $A[i] &#x3D; [v _ 1 \bmod i &#x3D; 0]$。</p><p>设 $B[i]$ 表示仅用第二种物品装满 $i$ 体积的方案数，显然 $B[i] &#x3D; [v _ 2 \bmod i &#x3D; 0]$。</p><p>直接上 DP。设 $C[i]$ 为结果，即任意使用第一种或第二种物品，装满 $i$ 体积的方案数。DP 方程为：</p><p>$$<br>C[i] &#x3D; \displaystyle \sum _ {j + k &#x3D; i} A[j] B[k] (i \le m)<br>$$</p><p>朴素算法需要 $O(m ^ 2)$ 的时间。不过相信来这里的读者很轻松能看出来：这是个卷积的形式。</p><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p>设 $F(x) &#x3D; 1 + x ^ {v _ 1} + x ^ {2 v _ 1} + \cdots$，即 $\displaystyle \sum _ {i &#x3D; 0} ^ {\infty} x ^ {i v _ 1}$。</p><p>设 $G(x) &#x3D; 1 + x ^ {v _ 2} + x ^ {2 v _ 2} + \cdots$，即 $\displaystyle \sum _ {i &#x3D; 0} ^ {\infty} x ^ {i v _ 2}$。</p><p>这是把上面的卷积写成多项式形式之后的结果。</p><p>用 FFT 将两个多项式相乘，新多项式的系数刚好就是 DP 的答案。这相当于完成了一次卷积。</p><p>当然，别看式子的项数是 $\infty$，实际上我们只需要用到前 $m$ 项（把 $m$ 之后的项砍掉即可）。</p><p>这一步我们用 FFT 优化了一个特殊的 DP 方程，时间复杂度 $O(m \log m)$。</p><h1 id="当-n-更大时……"><a href="#当-n-更大时……" class="headerlink" title="当 n 更大时……"></a>当 n 更大时……</h1><p>上面的方法还行得通吗？</p><p>分别给 $n$ 个物品造一条多项式（$F(x), G(x), \dots$），长度都要是 $m$。耗时 $O(nm)$</p><p>逐一相乘，每次耗时 $O(m \log m)$，总共 $n$ 次乘法。总时间 $O(nm \log m)$。</p><p>别忘了 $n, m \le 10 ^ 5$……拿个 30pts 还是可以的（狗头），总比直接 DP $O(nm ^ 2)$ 强（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i = 1 to n:</span><br><span class="line">    for j = 0 to m, j += v[i]:</span><br><span class="line">        f[i][j] += 1</span><br><span class="line">ans = Poly()</span><br><span class="line">for i = 1 to n:</span><br><span class="line">    ans = ans * f[i] // O(m log m)</span><br><span class="line">print(ans, i = 1 to m)</span><br></pre></td></tr></table></figure><h1 id="干嘛要相乘？"><a href="#干嘛要相乘？" class="headerlink" title="干嘛要相乘？"></a>干嘛要相乘？</h1><p>全部取 $\ln$，<strong>加起来</strong>，再 $\exp$ 回去。只用两次 FFT。不用一条一条相乘了。</p><p>瓶颈仍在造式子的 $O(nm)$ 上，同时相加起来也要 $O(nm)$ 时间</p><h1 id="利用函数的性质"><a href="#利用函数的性质" class="headerlink" title="利用函数的性质"></a>利用函数的性质</h1><p>设第 $i$ 种物品的体积是 $v$，令其生成函数为 $F(x)$。</p><p>则 $F(x) &#x3D; 1 + x ^ {v} + x ^ {2v} + x ^ {3v} + \cdots$</p><p>不用管 $x$ 的取值范围，我们可以只关注系数。因此我们可以大胆地令 $|x| &lt; 1$。</p><p>$$<br>\begin {split}<br>    F(x) &amp; &#x3D; 1 + x ^ {v} + x ^ {2v} + x ^ {3v} + \cdots \<br>         &amp; &#x3D; 1 + (x ^ v) + (x ^ v) ^ 2 + (x ^ v) ^ 3 + \cdots \<br>         &amp; &#x3D; \dfrac {1} {1 - x ^ v}<br>\end {split}<br>$$</p><p>生成函数的取值是没有意义的，它的核心在于系数的变换。</p><h1 id="我们要干什么？"><a href="#我们要干什么？" class="headerlink" title="我们要干什么？"></a>我们要干什么？</h1><p>对这 $n$ 个 $\dfrac {1} {1 - x ^ v}$ 取一遍 $\ln$，加起来，$\exp$。</p><h1 id="求这个分式的-Ln"><a href="#求这个分式的-Ln" class="headerlink" title="求这个分式的 Ln"></a>求这个分式的 Ln</h1><p>$$<br>\begin {split}<br>    \ln \dfrac {1} {1 - x ^ v} &amp; &#x3D; \ln 1 - \ln (1 - x ^ v) \<br>                               &amp; &#x3D; 0 - \ln (1 - x ^ v)<br>\end {split}<br>$$</p><p>诶等等……$\ln (1 - x ^ v)$ 怎么算呢？</p><h1 id="大胆猜想，不用求证"><a href="#大胆猜想，不用求证" class="headerlink" title="大胆猜想，不用求证"></a>大胆猜想，<del>不用求证</del></h1><p>别忘了我们是 OIer，可以借助程序来找找规律啊。</p><p>拷个 $\ln$ 板子来玩玩</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">1</span>; a[v] = <span class="number">-1</span>; <span class="comment">// 表示函数：F(x) = 1 - x ^ v</span></span><br><span class="line">  lim = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (lim &lt; n) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Log</span>(a, lim);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试试运行结果？</p><p>首先找到一个规律：数字只在 $v, 2v, 3v, \cdots$ 这些位置出现。</p><p>对数字敏感点吧。很明显，第 $v$ 位上的数字 $998244352 \equiv -1 \pmod {998244353}$。</p><p>那第 $2v$ 位上的 $499122176$ 是什么呢？注意到这个数字差不多是 $998244353$ 的一半。</p><p><img src="https://i.loli.net/2020/03/30/5swyjbhGAlBeEZJ.png"></p><p>所以 $499122176 \equiv -\dfrac {1} {2}$</p><p><img src="https://i.loli.net/2020/03/30/4WarUEQVKjsz98Y.png"></p><p>所以第 $3v$ 位上的 $665492635 \equiv -\dfrac {1} {3}$</p><p>可以继续验证第 $4v$ 位上的 $249561088 \equiv -\dfrac {1} {4}$。</p><p>大胆猜想：$\ln (1 - x ^ v) &#x3D; \displaystyle \sum _ {i &#x3D; 1} ^ {\infty} - \dfrac {1} {i} x ^ {iv} &#x3D; - \displaystyle \sum _ {i &#x3D; 1} ^ {\infty} \dfrac {1} {i} x ^ {iv}$</p><h1 id="严谨证明"><a href="#严谨证明" class="headerlink" title="严谨证明"></a>严谨证明</h1><p>设 $G(x) &#x3D; \ln F(x) &#x3D; \ln (1 - x ^ v)$</p><p>取导数，$G’(x) &#x3D; \dfrac {F’(x)} {F(x)} &#x3D; \dfrac {(1 - x ^ v)’} {1 - x ^ v} &#x3D; \dfrac {- v x ^ {v - 1}} {1 - x ^ v} &#x3D; - v x ^ {v - 1} \dfrac {1} {1 - x ^ v}$</p><p>注意到 $\dfrac {1} {1 - x ^ v} &#x3D; \displaystyle \sum _ {i &#x3D; 0} ^ {\infty} x ^ {iv}$。</p><p>$$<br>\begin {split}<br>    G’(x) &amp;&#x3D; - v x ^ {v - 1} \displaystyle \sum _ {i &#x3D; 0} ^ {\infty} x ^ {iv} \<br>          &amp;&#x3D; \displaystyle \sum _ {i &#x3D; 0} ^ {\infty} - v x ^ {iv + v - 1} \<br>          &amp;&#x3D; \displaystyle \sum _ {i &#x3D; 0} ^ {\infty} - v x ^ {(i + 1)v - 1} \<br>          &amp;&#x3D; \displaystyle \sum _ {i &#x3D; 1} ^ {\infty} - v x ^ {iv - 1} \<br>\end {split}<br>$$</p><p>求导。$\displaystyle \int ax ^ k &#x3D; \dfrac {1} {k + 1} a x ^ {k + 1} + C$ <a href="../math-notes/#note-2-4">[Link↗]</a>。因为 $G_0 &#x3D; 0$，所以 $C &#x3D; 0$。</p><p>$$<br>\begin {split}<br>    \int G’(x) &amp;&#x3D; \int \displaystyle \sum _ {i &#x3D; 1} ^ {\infty} - v x ^ {iv - 1} \<br>               &amp;&#x3D; \displaystyle \sum _ {i &#x3D; 1} ^ {\infty} \int - v x ^ {iv - 1} \<br>               &amp;&#x3D; \displaystyle \sum _ {i &#x3D; 1} ^ {\infty} - \dfrac {1} {iv} v x ^ {iv} \<br>               &amp;&#x3D; \displaystyle \sum _ {i &#x3D; 1} ^ {\infty} - \dfrac {1} {i} x ^ {iv} \<br>               &amp;&#x3D; - \displaystyle \sum _ {i &#x3D; 1} ^ {\infty} \dfrac {1} {i} x ^ {iv}<br>\end {split}<br>$$</p><p>证毕。</p><h1 id="求-Ln-完成"><a href="#求-Ln-完成" class="headerlink" title="求 Ln 完成"></a>求 Ln 完成</h1><p>结论：$\ln \dfrac {1} {1 - x ^ v} &#x3D; \ln 1 - \ln (1 - x ^ v) &#x3D; 0 - \left ( -\displaystyle \sum _ {i &#x3D; 1} ^ {\infty} \dfrac {1} {i} x ^ {iv} \right ) &#x3D; \displaystyle \sum _ {i &#x3D; 1} ^ {\infty} \dfrac {1} {i} x ^ {iv}$</p><p>当然上限 $\infty$ 也是取到 $m$ 就可以了。程序上，将所有 <code>a[k * v[i]]</code>（$k \cdot v[i] \le m$）的地方加上 $\dfrac {1} {k}$。</p><p>下一步要把它们全部加起来。</p><p>好像又遇到了个问题。初始化一条多项式的时间为 $O(\dfrac {m} {v})$，最多为 $O(m)$。而我们有 $n$ 条式子要处理……</p><p>解决方案是将所有 $v$ 相同的多项式一起处理。即 $\displaystyle \sum _ {i &#x3D; 1} ^ {m} \dfrac {1} {i} x ^ {iv}$ 乘上 $\mathrm {cnt} [v]$ 倍。</p><p>总时间是调和级数级别的，复杂度为 $O(m \log m)$。加上 Exp 的 $O(m \log m)$，总复杂度为 $O(m \log m)$。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = <span class="number">100000</span> * <span class="number">8</span> + <span class="number">10</span>; <span class="comment">// 开足空间！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPri = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kPriInv = <span class="number">332748118</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> get = <span class="built_in">getchar</span>();</span><br><span class="line">  LL res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(get)) get = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(get)) &#123;</span><br><span class="line">    res = res * <span class="number">10</span> + get - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    get = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fpow</span><span class="params">(LL x, LL k)</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans = ans * x % kMod;</span><br><span class="line">    x = x * x % kMod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fadd</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x += y) &gt;= kMod ? x - kMod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fdec</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + kMod : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">RaderSort</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = (n &gt;&gt; <span class="number">1</span>); (j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Ntt</span><span class="params">(LL* a, <span class="type">int</span> n, <span class="type">bool</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RaderSort</span>(a, n);</span><br><span class="line">  LL pri = opt ? kPri : kPriInv;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    LL unit = <span class="built_in">Fpow</span>(pri, (kMod - <span class="number">1</span>) / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">      LL w = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> mid = i + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (len &gt;&gt; <span class="number">1</span>); ++j) &#123;</span><br><span class="line">        LL tmp = w * a[mid + j] % kMod;</span><br><span class="line">        a[mid + j] = <span class="built_in">Fdec</span>(a[i + j], tmp);</span><br><span class="line">        a[i + j] = <span class="built_in">Fadd</span>(a[i + j], tmp);</span><br><span class="line">        w = w * unit % kMod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">    LL inv = <span class="built_in">Fpow</span>(n, kMod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      a[i] = a[i] * inv % kMod;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="type">inv_t</span>[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">InvIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">inv_t</span>, <span class="type">inv_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(a, a + n, <span class="type">inv_t</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">inv_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = <span class="built_in">Fdec</span>(<span class="number">2</span>, <span class="type">inv_t</span>[i] * b[i] % kMod) * b[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">fill</span>(b + n, b + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inv</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(b, b + n, <span class="number">0</span>);</span><br><span class="line">  b[<span class="number">0</span>] = <span class="built_in">Fpow</span>(a[<span class="number">0</span>], kMod - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">InvIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Deri</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">    a[i] = (i + <span class="number">1</span>) * a[i + <span class="number">1</span>] % kMod;</span><br><span class="line">  a[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inte</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    a[i + <span class="number">1</span>] = a[i] * <span class="built_in">Fpow</span>(i + <span class="number">1</span>, kMod - <span class="number">2</span>) % kMod;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="type">log_t</span>[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Log</span><span class="params">(LL* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">log_t</span>, <span class="type">log_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Inv</span>(a, <span class="type">log_t</span>, n);</span><br><span class="line">  <span class="built_in">Deri</span>(a, lim);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">log_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    a[i] = a[i] * <span class="type">log_t</span>[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(a, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">Inte</span>(a, n);</span><br><span class="line">  <span class="built_in">fill</span>(a + n, a + lim, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">LL <span class="type">exp_t</span>[kMaxN], exp_a[kMaxN]; <span class="comment">// 总要记得清空临时数组！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ExpIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">exp_t</span>, <span class="type">exp_t</span> + lim, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">copy</span>(b, b + n, <span class="type">exp_t</span>);</span><br><span class="line">  <span class="built_in">Log</span>(<span class="type">exp_t</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="type">exp_t</span>[i] = <span class="built_in">Fdec</span>(a[i], <span class="type">exp_t</span>[i]);</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">exp_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = b[i] * (<span class="type">exp_t</span>[i] + <span class="number">1</span>) % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Exp</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(b, b + n, <span class="number">0</span>); <span class="comment">// 总要记得清空输出数组！</span></span><br><span class="line">  b[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// a[0] = 0, b[0] = e ^ a[0] = e ^ 0 = 1.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">ExpIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n：商品数</span></span><br><span class="line"><span class="comment">// m：输出的数量</span></span><br><span class="line"><span class="type">int</span> n, m, lim;</span><br><span class="line">LL v[kMaxN];</span><br><span class="line">LL cnt[kMaxN];</span><br><span class="line">LL a[kMaxN], b[kMaxN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">Read</span>(), m = <span class="built_in">Read</span>();</span><br><span class="line">  <span class="comment">// 注意：输出时要用 [1, m]！</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    v[i] = <span class="built_in">Read</span>();</span><br><span class="line">    ++cnt[v[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// O(mlogm)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">      <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= m; j += i) &#123;</span><br><span class="line">        ++cur;</span><br><span class="line">        a[j] = (a[j] + <span class="built_in">Fpow</span>(cur, kMod - <span class="number">2</span>) * cnt[i] % kMod) % kMod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lim = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (lim &lt; m + <span class="number">10</span>) lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Exp</span>(a, b, lim);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, b[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式求逆（简要笔记）</title>
      <link href="/2020-03-26-poly-inv-brief/"/>
      <url>/2020-03-26-poly-inv-brief/</url>
      
        <content type="html"><![CDATA[<p>对于多项式 $A(x)$，求一个 $B(x)$，使得 $A(x) B(x) \equiv 1 \pmod {x ^ n}$。</p><p>阅读这篇文章你需要：</p><ol><li>多项式乘法</li></ol><span id="more"></span><h1 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h1><p>对于 $A(x) B(x) \equiv 1 \pmod {x ^ n}$，已知 $A(x)$，求 $B(x)$。两者的次数都应该是 $n$。</p><h1 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h1><p>假设 $A(x) B _ 0 (x) \equiv 1 \pmod {x ^ \frac n 2}$，已经求出 $B _ 0 (x)$。</p><p>由于 $A(x) B(x) \equiv 1 \pmod {x ^ n}$，显然将 $\bmod {x ^ n}$ 改成 $\bmod {x ^ \frac n 2}$ 也是可以的。</p><p>$$<br>\begin {gather}<br>    \left {<br>        \begin {split}<br>                A(x) B(x) &amp; \equiv 1 \pmod {x ^ \frac n 2} \<br>            A(x) B _ 0(x) &amp; \equiv 1 \pmod {x ^ \frac n 2}<br>        \end {split}<br>    \right . \nonumber \<br>    \begin {split}<br>                           A(x) (B(x) - B _ 0 (x)) &amp; \equiv 0 \pmod {x ^ \frac n 2} \<br>                                  B(x) - B _ 0 (x) &amp; \equiv 0 \pmod {x ^ \frac n 2} \<br>                            (B(x) - B _ 0 (x)) ^ 2 &amp; \equiv 0 \pmod {x ^ n} \<br>       B(x) ^ 2 + B _ 0 (x) ^ 2 - 2 B(x) B _ 0 (x) &amp; \equiv 0 \pmod {x ^ n} \<br>A(x) (B(x) ^ 2 + B _ 0 (x) ^ 2 - 2 B(x) B _ 0 (x)) &amp; \equiv 0 \pmod {x ^ n} \<br>           B(x) + A(x) B _ 0 (x) ^ 2 - 2 B _ 0 (x) &amp; \equiv 0 \pmod {x ^ n} \<br>                                              B(x) &amp; \equiv 2 B _ 0 (x) - A(x) B _ 0 (x) ^ 2 \pmod {x ^ n} \<br>                                              B(x) &amp; \equiv B _ 0 (x) (2 - A(x) B _ 0 (x)) \pmod {x ^ n}<br>    \end {split} \nonumber<br>\end {gather}<br>$$</p><p>故得到递推公式：$B(x) \equiv B _ 0 (x) (2 - B _ 0 (x)) \pmod {x ^ n}$。</p><h1 id="翻倍"><a href="#翻倍" class="headerlink" title="翻倍"></a>翻倍</h1><p>“二元函数”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LL <span class="type">inv_t</span>[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">InvIter</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> lim = (n &lt;&lt; <span class="number">1</span>); <span class="comment">// 乘法：保留空间 (1)</span></span><br><span class="line">  <span class="built_in">fill</span>(<span class="type">inv_t</span>, <span class="type">inv_t</span> + lim, <span class="number">0</span>); <span class="comment">// 不建议删去</span></span><br><span class="line">  <span class="built_in">copy</span>(a, a + n, <span class="type">inv_t</span>); <span class="comment">// 乘法：保留空间 (2)</span></span><br><span class="line">  <span class="built_in">Ntt</span>(<span class="type">inv_t</span>, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">    b[i] = <span class="built_in">Fdec</span>(<span class="number">2</span>, <span class="type">inv_t</span>[i] * b[i] % kMod) * b[i] % kMod;</span><br><span class="line">  <span class="built_in">Ntt</span>(b, lim, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">fill</span>(b + n, b + lim, <span class="number">0</span>); <span class="comment">// 记得清零！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Inv</span><span class="params">(LL* a, LL* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fill</span>(b, b + n, <span class="number">0</span>);</span><br><span class="line">  b[<span class="number">0</span>] = <span class="built_in">Fpow</span>(a[<span class="number">0</span>], kMod - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">InvIter</span>(a, b, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泰勒级数、牛顿迭代（简要笔记）</title>
      <link href="/2020-03-25-taylor-series-newton-iter-brief/"/>
      <url>/2020-03-25-taylor-series-newton-iter-brief/</url>
      
        <content type="html"><![CDATA[<p>大名鼎鼎的泰勒公式：</p><p>$$<br>F(x) &#x3D; \displaystyle \sum _ {i &#x3D; 0} ^ {\infty} F ^ {(i)} (x _ 0) \dfrac {(x - x _ 0) ^ i} {i!}<br>$$</p><p>阅读这篇文章你需要：</p><ol><li>有一定多项式基础</li></ol><span id="more"></span><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>多项式求导、积分 <a href="../math-notes/#note-2">[Link↗]</a></li></ul><h1 id="麦克劳林级数"><a href="#麦克劳林级数" class="headerlink" title="麦克劳林级数"></a>麦克劳林级数</h1><p>$$<br>F(x) &#x3D; \displaystyle \sum _ {i &#x3D; 0} ^ {\infty} F ^ {(i)} (0) \dfrac {x ^ i} {i!}<br>     &#x3D; F(0) + F’(0) x + F’’(0) \dfrac {x ^ 2} {2!} + \cdots<br>$$</p><p>感性理解：对序列 $A$ 的 EGF 求导等价于将 $A$ 前移一位。这里序列 $A$ 是 $(F(0), F’(0), \cdots)$，对其求导仍能满足等式。</p><p>知乎上面的部分回答都不够严谨。具体证明需用积分。</p><h1 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h1><p>泰勒展开是麦克劳林级数的扩展</p><p>$$<br>F(x) &#x3D; \displaystyle \sum _ {i &#x3D; 0} ^ {\infty} F ^ {(i)} (x _ 0) \dfrac {(x - x _ 0) ^ i} {i!}<br>$$</p><h1 id="牛顿迭代（多项式）"><a href="#牛顿迭代（多项式）" class="headerlink" title="牛顿迭代（多项式）"></a>牛顿迭代（多项式）</h1><p>有趣的是，泰勒展开在 $x$ 为多项式的时候也能成立。</p><p>$$<br>G(F(x)) &#x3D; \displaystyle \sum _ {i &#x3D; 0} ^ {\infty} G ^ {(i)} (F_0(x)) \dfrac {(F(x) - F_0(x)) ^ i} {i!}<br>$$</p><p>这里 $F _ 0 (x)$ 可以是一个任意的多项式。</p><p>我们想要找到一个 $F(x)$ 使得对于已知的 $G(x)$，有 $G(F(x)) \equiv 0 \pmod {x ^ n}$。</p><p>假设我们已经知道一个 $F _ 0 (x)$ 使得 $G(F _ 0 (x)) \equiv 0 \pmod {x ^ {\frac {n} {2}}}$。</p><p>考虑在 $\bmod {x ^ n}$ 意义下：</p><p>$$<br>\begin {split}<br>0 \equiv G(F(x)) &amp;\equiv G(F _ 0 (x)) + G’(F _ 0 (x)) (F(x) - F _ 0(x)) \ &amp; \ \ \ \  + G’’(F _ 0 (x)) \dfrac {(F(x) - F _ 0 (x)) ^ 2} {2!} + \cdots<br>\end {split} \pmod {x ^ n}<br>$$</p><p>注意由于（很显然地）$F(x)$ 和 $F _ 0 (x)$ 的前 $\frac {n} {2}$ 项是相同的，所以</p><p>$$<br>\begin {split}<br>F(x) - F _ 0 (x) &amp;\equiv 0 \pmod {x ^ {\frac {n} {2}}} \<br>(F(x) - F _ 0 (x)) ^ 2 &amp;\equiv 0 \pmod {x ^ n} \<br>\end {split}<br>$$</p><p>因此所有 $G’’(F _ 0 (x)) \dfrac {(F(x) - F _ 0 (x)) ^ 2} {2!} + \cdots$ 后面的项在 $\bmod {x ^ n}$ 意义下都是 $0$，可以舍去。</p><p>故</p><p>$$<br>\begin {split}<br>0 \equiv G(F(x)) &amp; \equiv G(F _ 0 (x)) + G’(F _ 0 (x)) (F(x) - F _ 0(x)) \pmod {x ^ n} \<br>0 &amp; \equiv G(F _ 0 (x)) + G’(F _ 0 (x)) (F(x) - F _ 0(x)) \pmod {x ^ n} \<br>F(x) &amp; \equiv F _ 0 (x) - \dfrac {G(F _ 0(x))} {G’(F _ 0(x))} \pmod {x ^ n}<br>\end {split}<br>$$</p><p>第三行式子可以由第二行式子移项推出。请读者自己手玩（滑稽）。</p><p><strong>结论</strong> 多项式牛顿迭代的公式：$F(x) \equiv F _ 0 (x) - \dfrac {G(F _ 0(x))} {G’(F _ 0(x))} \pmod {x ^ n}$</p><p>记住它，$F _ 0$ 减去 $G$ 在 $F _ 0$ 上的函数值与导数之比。该公式在多项式运算中经常会用到。</p>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 LaTex 的小记</title>
      <link href="/2020-03-19-latex-notes/"/>
      <url>/2020-03-19-latex-notes/</url>
      
        <content type="html"><![CDATA[<p>记录一些 $\rm \LaTeX$ 的使用笔记。</p><span id="more"></span><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p><code>\DeclareMathOperator</code></p><p>用 <code>\DeclareMathOperator &#123;符号表达方式&#125; &#123;显示内容&#125;</code> 来自定义一个自己的 LaTeX 命令。</p><p>众所周知异或运算符 <code>\xor</code> 在 LaTeX 里面是没法渲染的。</p><p>可以通过 <code>\DeclareMathOperator &#123;\xor&#125; &#123;\oplus&#125;</code> 来定义 <code>\xor</code>——对 LaTeX 说：“这个符号表示公式 <code>&#123;\oplus&#125;</code>！”。</p><p>举个例子：对比一下 $\DeclareMathOperator {\xor} {\oplus} a \xor b$ | $\DeclareMathOperator {\xor} {xor} a \xor b$ | $a {\rm xor} b$（可以右键查看 LaTeX 命令）</p><p>注意在这个例子中，显示内容默认是正体（<code>\rm</code>）的，而且两边总各有一个空格。而普通的 <code>\rm</code>（或 <code>\mathrm</code>）没有。</p><p>可以在 <code>\DeclareMathOperator</code> 后面加上一个星号，下面是效果对比：</p><ol><li>$\DeclareMathOperator   {\MySum} {\mathrm {Plus}} \displaystyle \MySum _ {i &#x3D; 0} ^ {n - 1}$（没星号）</li><li>$\DeclareMathOperator * {\MySum} {\mathrm {Plus}} \displaystyle \MySum _ {i &#x3D; 0} ^ {n - 1}$（有星号）</li></ol><p>同样右键查看命令。</p>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FWT - 快速沃尔什变换（详解）</title>
      <link href="/2020-03-16-fwt-notes-detailed/"/>
      <url>/2020-03-16-fwt-notes-detailed/</url>
      
        <content type="html"><![CDATA[<!-- 打了 code_check 标签的代码需要检查 Δ --><p>$\DeclareMathOperator {\Xor} {xor} \DeclareMathOperator {\And} {and} \DeclareMathOperator {\Or} {or} \DeclareMathOperator {\fwt} {FWT} \DeclareMathOperator {\ifwt} {IFWT} \DeclareMathOperator {\fft} {FFT}$快速沃尔什变换用以解决<strong>位运算卷积</strong>问题。</p><!-- 偷偷放一个 \DeclareMathOperator 在第一句话之前 --><p>阅读这篇文章你需要：</p><ol><li>已经学会（至少了解）快速傅里叶变换</li></ol><span id="more"></span><h1 id="0）前置知识"><a href="#0）前置知识" class="headerlink" title="0）前置知识"></a>0）前置知识</h1><ul><li>高维前缀和 <a href="../math-notes/#note-1">[Link↗]</a></li></ul><p>为了方便计算（参考 FFT），下文中序列长度 $n$ 默认都是 $2$ 的正整数幂。</p><p>代码中 <code>len</code> 表示二进制长度，换句话说，<code>n = (1 &lt;&lt; len)</code>。</p><blockquote><p>  <strong>ps</strong>：经查证，处理 $\Or, \And$ 卷积的“FWT 算法”严格来说并不是 FWT。FWT 专指 $\Xor$ 卷积。</p><p>  但由于他们思想相通（事实上就是更换了不同的 $f$ 函数），因此本文将它们放在一起讲（都当作“FWT”）。</p><p>  另外有一个利用高维前缀和的 FMT 算法，参见本文第五节 <a href="#fmt---%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2">[Link↗]</a>。</p></blockquote><h1 id="1）什么是“位运算卷积”？"><a href="#1）什么是“位运算卷积”？" class="headerlink" title="1）什么是“位运算卷积”？"></a>1）什么是“位运算卷积”？</h1><p>先看看<strong>多项式乘法</strong>中，乘法前后序列的变化情况。如果用序列 $A _ i$ 表示多项式 $x^i$ 项系数的话，就会有<br>$$<br>C _ i &#x3D; \displaystyle \sum _ {j + k &#x3D; i} A _ j B _ k<br>$$</p><p>这条式子将所有满足 $j + k &#x3D; i$ 的 $A _ j$ 和 $B _ k$ 之积加到 $C _ i$ 上。如果 $j$ 和 $k$ 之间不是加法呢？</p><p>把式子修改一下，将 $j + k &#x3D; i$ 的加号换成位运算符号：</p><p>$$<br>\begin {split}<br>C _ i &#x3D; \displaystyle \sum _ {j \Or k &#x3D; i} A _ j B _ k<br>&amp;\iff<br>C _ i &#x3D; \displaystyle \sum _ {j \cup k &#x3D; i} A _ j B _ k \<br>C _ i &#x3D; \displaystyle \sum _ {j \And k &#x3D; i} A _ j B _ k<br>&amp;\iff<br>C _ i &#x3D; \displaystyle \sum _ {j \cap k &#x3D; i} A _ j B _ k \<br>C _ i &#x3D; \displaystyle \sum _ {j \Xor k &#x3D; i} A _ j B _ k<br>&amp;\iff<br>C _ i &#x3D; \displaystyle \sum _ {j \Delta k &#x3D; i} A _ j B _ k<br>\end {split}<br>$$</p><p>这三条式子被称为<strong>位运算卷积</strong>。三条式子分别叫做 $\Or$ 卷积、$\And$ 卷积和 $\Xor$ 卷积。</p><p>信息学常用二进制来表示集合。${ \Or, \And, \Xor }$ 可以分别对应集合运算 ${ \cup, \cap, \Delta }$（$\Delta$ 为对称差，集合的异或运算），所以也可以写成右边的样子。</p><p>一般地，形如<br>$$<br>C _ i &#x3D; \displaystyle \sum _ {j \oplus k &#x3D; i} A _ j B _ k<br>$$<br>这样的式子叫做<strong>卷积</strong>，这里 $\oplus$ 可以是任何运算。比如，当 $\oplus$ 为加法（$+$）时，这条卷积就是普通的多项式乘法（不妨记为 $C &#x3D; A * B$）；当 $\oplus$ 分别为 $\Or, \And, \Xor$ 时，就是三条位运算卷积（记为 $C &#x3D; A \oplus B$）。</p><h1 id="2）FWT-的核心在于序列变换"><a href="#2）FWT-的核心在于序列变换" class="headerlink" title="2）FWT 的核心在于序列变换"></a>2）FWT 的核心在于序列变换</h1><p>FFT 将序列 $A$ 进行（代入单位根 $\omega _ n ^ i$ 的）求值，得到新的序列 $\fft (A)$，使得对于 $A, B$ 的卷积可以通过 $\fft (A), \fft (B)$ 相乘来完成。</p><p>$$<br>A \rightarrow \fft (A)<br>$$</p><p>$$<br>\fft (A * B) _ i &#x3D; \fft (A) _ i \times \fft (B) _ i<br>$$</p><p>同理，我们也可以定义一个 $\fwt (A)$，使得 $\fwt (A \oplus B) _ i &#x3D; \fwt (A) _ i \times \fwt (B) _ i$。这里 $\oplus$ 表示上面三种运算中的任意一个。</p><p>当然我们知道 $\fft (A) _ i &#x3D; \displaystyle \sum _ {k &#x3D; 0} ^ {n - 1} A _ k (\omega _ n ^ i) ^ k$（也就是将 $A _ k$ 组成的多项式代入 $x &#x3D; \omega _ n ^ i$ 进行求值，参见 FFT）。因此，关键在于怎么找到这样一个 $\fwt (A)$ 满足条件。</p><h1 id="3）寻找合适的-FWT-变换"><a href="#3）寻找合适的-FWT-变换" class="headerlink" title="3）寻找合适的 FWT 变换"></a>3）寻找合适的 FWT 变换</h1><p>让我们不妨想一想：$\fwt (A)$ 一定要包含 $A$ 足够的信息。</p><p>所以可以猜想，它肯定是形如 $\displaystyle \sum \text {xxx} \ A$ 这样的式子！！！</p><p>为什么？<del>盲猜</del></p><p>反正猜对了，后面会证明给你看。不妨先将它表示为 $\fwt (A) _ i &#x3D; \displaystyle \sum _ {l} f(i, l) A _ l$。$f(i, j)$ 就是 $\text {xxx}$。</p><p>让我们换一种方式表示卷积：</p><p>$$<br>C _ i &#x3D; \displaystyle \sum _ {j \oplus k &#x3D; i} A _ j B _ k<br>&#x3D; \displaystyle \sum _ {j} \displaystyle \sum _ {k} [j \oplus k &#x3D; i] A _ j B _ k<br>$$</p><p>在这种表示下，$\fwt$ 就可以写成：</p><p>$$<br>\begin {split}<br>    \fwt (C) _ i &amp;&#x3D; \displaystyle \sum _ {l} f(i, l) C _ l \<br>                          &amp;&#x3D; \displaystyle \sum _ {l} f(i, l) \displaystyle \sum _ {j} \displaystyle \sum _ {k} [j \oplus k &#x3D; l] A _ j B _ k \<br>                          &amp;&#x3D; \displaystyle \sum _ {l} \displaystyle \sum _ {j} \displaystyle \sum _ {k} f(i, l) [j \oplus k &#x3D; l] A _ j B _ k \<br>                          &amp;&#x3D; \displaystyle \sum _ {j} \displaystyle \sum _ {k} f(i, j \oplus k) A _ j B _ k<br>\end {split}<br>$$</p><p>看到最后一行式子，假如我们能将 $f(i, j \oplus k)$ 拆成两部分 $f(i, j), f(i, k)$ 的乘积呢？这样就可以进一步推导了。<br>$$<br>f(i, j \oplus k) &#x3D; f(i, j) \times f(i, k)<br>$$</p><p>为什么呢？请看推导：<br>$$<br>\begin {split}<br>    \displaystyle \sum _ {j} \displaystyle \sum _ {k} f(i, j \oplus k) A _ j B _ k<br>    &amp;&#x3D; \displaystyle \sum _ {j} \displaystyle \sum _ {k} f(i, j) f(i, k) A _ j B _ k \<br>    &amp;&#x3D; \displaystyle \sum _ {j} f(i, j) A _ j \displaystyle \sum _ {k} f(i, k) B _ k \<br>    &amp;&#x3D; \left ( \displaystyle \sum _ {j} f(i, j) A _ j \right ) \left ( \displaystyle \sum _ {k} f(i, k) B _ k \right )<br>\end {split}<br>$$</p><p>因为 $j, k$ 两层 Sigma 是相互独立的，所以可以加上括号将它们分开。</p><p>前后两部分不就是 $\fwt (A)$ 和 $\fwt (B)$ 了嘛！</p><p>只要（对于运算 $\oplus$）存在一个函数 $f(i, j)$，使得 $f(i, j \oplus k) &#x3D; f(i, j) f(i, k)$，那么 $\fwt$ 就大功告成了！我们只需要对 $\displaystyle \sum _ {j} f(i, j) A _ j$ 求值即可。当然，我们还要找一个 $\mathrm {IFWT}$ 进行逆变换。不过这是后面的事了。</p><h1 id="4）构造合适的-f"><a href="#4）构造合适的-f" class="headerlink" title="4）构造合适的 f"></a>4）构造合适的 f</h1><p>到这里已经推不下去了，需要进行构造<del>（人类智慧）</del>。</p><p>结论：</p><ul><li><p><strong>【或卷积】</strong> $f(i, j) &#x3D; [j \subseteq i]$</p><p>证明：$f(i, j \cup k) &#x3D; [(j \cup k) \subseteq i] &#x3D; [j \subseteq i] [k \subseteq i] &#x3D; f(i, j) f(i, k)$。</p></li><li><p><strong>【与卷积】</strong> $f(i, j) &#x3D; [j \supseteq i]$</p><p>证明：$f(i, j \cap k) &#x3D; [(j \cap k) \supseteq i] &#x3D; [j \supseteq i] [k \supseteq i] &#x3D; f(i, j) f(i, k)$。</p></li><li><p><strong>【异或卷积】</strong> 稍微复杂一点</p><p>记 $\mathrm {cnt} (i)$ 表示二进制数 $i$ 中 $1$ 的位数，即 <code>__builtin_popcount(i)</code>。如 $14 &#x3D; (1110) _ 2$ 的 $\mathrm {cnt}$ 为 $3$。</p><p>$f(i, j) &#x3D; (-1) ^ {\mathrm {cnt} (i \And j)}$</p><p>证明：</p><p>$$<br>\begin {align}<br>f(i, j \Xor k) &amp;&#x3D; (-1) ^ {\mathrm {cnt} (i \And (j \Xor k))} \tag {1} \<br>f(i, j) f(i, k) &#x3D; (-1) ^ {\mathrm {cnt} (i \And j)} (-1) ^ {\mathrm {cnt} (i \And k)} &amp;&#x3D; (-1) ^ {\mathrm {cnt} (i \And j) + \mathrm {cnt} (i \And k)} \tag {2}<br>\end {align}<br>$$</p><p>考虑式 $(1)$ 为什么会等于式 $(2)$。这需要满足 $-1$ 的指数<strong>奇偶性相同</strong>。$\mathrm {cnt} (i \And j) + \mathrm {cnt} (i \And k)$ 表示 $i, j$ 共有的 $1$ 的数量与 $i, k$ 共有的 $1$ 的数量之和。由于异或相同则消，所以由 $\mathrm {cnt} (i \And j) + \mathrm {cnt} (i \And k)$ 到 $\mathrm {cnt} (i \And (j \Xor k))$ 的过程中，每次只会消掉 $2$ 个数字 $1$（$i, j, k$ 都共有的 $1$ 的位置，$j, k$ 在此处异或成了 $0$），所以两者的奇偶性是相同的。</p></li></ul><p>由此，我们得到了三条式子：</p><p>$$<br>\begin {split}<br>    \mathrm  {or}&amp;: \fwt (A) _ i &#x3D; \displaystyle \sum _ {j} [j \subseteq i] A _ j \<br>    \mathrm {and}&amp;: \fwt (A) _ i &#x3D; \displaystyle \sum _ {j} [j \supseteq i] A _ j \<br>    \mathrm {xor}&amp;: \fwt (A) _ i &#x3D; \displaystyle \sum _ {j} (-1) ^ {\mathrm {cnt} (i \And j)} A _ j<br>\end {split}<br>$$</p><h1 id="5-FMT-快速莫比乌斯变换"><a href="#5-FMT-快速莫比乌斯变换" class="headerlink" title="5) FMT - 快速莫比乌斯变换"></a>5) FMT - 快速莫比乌斯变换</h1><p>现在可以直接求 $\Or$ 卷积和 $\And$ 卷积了。我们可以使用高维前缀和来计算子集和（$\Or$ 卷积），或者用类似的方法求出超集和（$\And$ 卷积）。这个求和的过程被称为 FMT。</p><p>别着急，代码在后面。求出 $A, B$ 两个序列的 FMT 之后，将两个新得到的序列点积（对应位置相乘）起来，这个点积结果就是 $C &#x3D; A \Or B$（$C &#x3D; A \And B$）的 FMT。</p><p>通过一步叫做 IFMT 的操作，将 $C$ 的 FMT 还原为 $C$，就得到了 $A, B$ 卷积的结果。利用高维差分可以还原前缀和之后的数组。IFMT 可由高维差分实现。</p><p>给出代码：</p><!--code_check--><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个函数极为相像。</span></span><br><span class="line"><span class="comment">// sign 表示关键位置的符号，输入 +1 表示进行 FMT（正向变换），输入 -1 表示进行 IFMT（反向变换）。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxLog = <span class="number">17</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = (<span class="number">1</span> &lt;&lt; kMaxLog) + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> get = <span class="built_in">getchar</span>(), res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(get)) get = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(get)) &#123;</span><br><span class="line">    res = res * <span class="number">10</span> + get - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    get = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> blen, n; <span class="comment">// blen = bit_len</span></span><br><span class="line">LL a[kMaxN], b[kMaxN], c[kMaxN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Print</span><span class="params">(LL* a, <span class="type">int</span> blen)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, c[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Times</span><span class="params">(LL* a, LL* b, LL* c, <span class="type">int</span> blen)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    c[i] = a[i] * b[i] % kMod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FmtOr</span><span class="params">(LL* a, <span class="type">int</span> blen, <span class="type">int</span> sign)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; blen; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">        a[i] = (a[i] + sign * a[i ^ (<span class="number">1</span> &lt;&lt; k)] + kMod) % kMod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FmtAnd</span><span class="params">(LL* a, <span class="type">int</span> blen, <span class="type">int</span> sign)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; blen; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (!(i &amp; (<span class="number">1</span> &lt;&lt; k)))</span><br><span class="line">        a[i] = (a[i] + sign * a[i ^ (<span class="number">1</span> &lt;&lt; k)] + kMod) % kMod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = (<span class="number">1</span> &lt;&lt; (blen = <span class="built_in">Read</span>()));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    a[i] = <span class="built_in">Read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    b[i] = <span class="built_in">Read</span>();</span><br><span class="line">  <span class="comment">// or 卷积</span></span><br><span class="line">  <span class="built_in">FmtOr</span>(a, blen, +<span class="number">1</span>), <span class="built_in">FmtOr</span>(b, blen, +<span class="number">1</span>); <span class="comment">// FMT</span></span><br><span class="line">  <span class="built_in">Times</span>(a, b, c, blen);</span><br><span class="line">  <span class="built_in">FmtOr</span>(a, blen, <span class="number">-1</span>), <span class="built_in">FmtOr</span>(b, blen, <span class="number">-1</span>), <span class="built_in">FmtOr</span>(c, blen, <span class="number">-1</span>); <span class="comment">// IFMT</span></span><br><span class="line">  <span class="built_in">Print</span>(c, blen);</span><br><span class="line">  <span class="comment">// and 卷积</span></span><br><span class="line">  <span class="built_in">FmtAnd</span>(a, blen, +<span class="number">1</span>), <span class="built_in">FmtAnd</span>(b, blen, +<span class="number">1</span>); <span class="comment">// FMT</span></span><br><span class="line">  <span class="built_in">Times</span>(a, b, c, blen);</span><br><span class="line">  <span class="built_in">FmtAnd</span>(a, blen, <span class="number">-1</span>), <span class="built_in">FmtAnd</span>(b, blen, <span class="number">-1</span>), <span class="built_in">FmtAnd</span>(c, blen, <span class="number">-1</span>); <span class="comment">// IFMT</span></span><br><span class="line">  <span class="built_in">Print</span>(c, blen);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6）f-的拆分性质"><a href="#6）f-的拆分性质" class="headerlink" title="6）f 的拆分性质"></a>6）f 的拆分性质</h1><p>$f$ 函数可以进行二进制拆分。记 $i _ k$ 表示数字 $i$ 的第 $k$ 位二进制（$k \in [0, len)$），则有：</p><p>$$<br>f(i, j) &#x3D; f(i _ 0, j _ 0) f(i _ 1, j _ 1) \cdots f(i _ {len - 1}, j _ {len - 1})<br>$$</p><p>大家可以将三个 $f$ 代进去算一算试试。</p><p>由乘法结合律可知，$f(i, j) &#x3D; f(i _ {len - 1}, j _ {len - 1}) f(i _ {[0, len - 1)}, j _ {[0, len - 1)})$。为了不要让公式过于辣眼睛（雾），下面用 $i _ {K}$ 表示 $i _ {len - 1}$，用 $i _ {B}$ 表示 $i _ {[0, len - 1)}$。$i _ K$ 即为 $i$ 的最高位，$i _ B$ 即为 $i$ 去掉最高位之后的值。</p><h1 id="7）拆分式子"><a href="#7）拆分式子" class="headerlink" title="7）拆分式子"></a>7）拆分式子</h1><p>令 $m &#x3D; \dfrac {n} {2}$，对于 $i \in [0, m)$：</p><p>$$<br>\begin {split}<br>\fwt (A) _ i &amp;&#x3D; \displaystyle \sum _ {j &#x3D; 0} ^ {n - 1} f(i, j) A _ j \<br>                      &amp;&#x3D; \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ j<br>                        +\displaystyle \sum _ {j &#x3D; m} ^ {n - 1} f(i, j) A _ j \<br>                      &amp;&#x3D; \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i _ K, j _ K) f(i _ B, j _ B) A _ j<br>                        +\displaystyle \sum _ {j &#x3D; m} ^ {n - 1} f(i _ K, j _ K) f(i _ B, j _ B) A _ j<br>\end {split}<br>$$</p><p>由于 $i \in [0, m)$，所以 $i _ K &#x3D; 0$；由于左边 Sigma 中 $j \in [0, m)$，所以 $j _ K \text {（左边）} &#x3D; 0$。</p><p>同理 $j _ K \text {（右边）} &#x3D; 1$。</p><p>$$<br>\begin {split}<br>                      &amp;&#x3D; \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(0, 0) f(i _ B, j _ B) A _ j<br>                        +\displaystyle \sum _ {j &#x3D; m} ^ {n - 1} f(0, 1) f(i _ B, j _ B) A _ j<br>\end {split}<br>$$</p><p>提取。同时由于 $i _ K &#x3D; 0$，所以 $i _ B &#x3D; i$。</p><p>$$<br>\begin {split}<br>                      &amp;&#x3D; f(0, 0) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i _ B, j _ B) A _ j<br>                        +f(0, 1) \displaystyle \sum _ {j &#x3D; m} ^ {n - 1} f(i _ B, j _ B) A _ j \<br>                      &amp;&#x3D; f(0, 0) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j _ B) A _ j<br>                        +f(0, 1) \displaystyle \sum _ {j &#x3D; m} ^ {n - 1} f(i, j _ B) A _ j<br>\end {split}<br>$$</p><p>进行一些变形。</p><p>$$<br>\begin {split}<br>                      &amp;&#x3D; f(0, 0) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ j<br>                        +f(0, 1) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ {j + m}<br>\end {split}<br>$$</p><p>于是</p><p>$$<br>\begin {split}<br>\fwt (A) _ i &amp;&#x3D; f(0, 0) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ j<br>                        +f(0, 1) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ {j + m}<br>\end {split}<br>$$</p><p>仿照以上步骤，易得</p><p>$$<br>\begin {split}<br>\fwt (A) _ {i + m} &amp;&#x3D; f(1, 0) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ j<br>                              +f(1, 1) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ {j + m}<br>\end {split}<br>$$</p><p><strong>故</strong></p><p>$$<br>\begin {split}<br>      \fwt (A) _ i &amp;&#x3D; f(0, 0) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ j<br>                              +f(0, 1) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ {j + m} \<br>\fwt (A) _ {i + m} &amp;&#x3D; f(1, 0) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ j<br>                              +f(1, 1) \displaystyle \sum _ {j &#x3D; 0} ^ {m - 1} f(i, j) A _ {j + m}<br>\end {split}<br>$$</p><p>这里遇到了一个麻烦。我们需要修改一下符号的含义。之前我们用 $A _ i$ 来表示序列的第 $i$ 项（$i \in [0, n)$），</p><p>现在 $A _ 0$ 表示 $A$ 的前半部分【$[0, m)$】，$A _ 1$ 表示 $A$ 的后半部分【$[m, n)$】。</p><p>$$<br>\begin {split}<br>      \fwt (A) _ i &amp;&#x3D; f(0, 0) \fwt (A _ 0) _ i + f(0, 1) \fwt (A _ 1) _ i \<br>\fwt (A) _ {i + m} &amp;&#x3D; f(1, 0) \fwt (A _ 0) _ i + f(1, 1) \fwt (A _ 1) _ i<br>\end {split}<br>$$</p><p><strong>规模减半。</strong></p><p>我们将三个位运算对应的 $f$ 分别代入上面的式子，就可以得到：</p><p>$$<br>\begin {split}<br>\Or&amp;: \left {<br>    \begin {split}<br>              \fwt (A) _ i &amp;&#x3D; \fwt (A _ 0) _ i \<br>        \fwt (A) _ {i + m} &amp;&#x3D; \fwt (A _ 0) _ i + \fwt (A _ 1) _ i<br>    \end {split}<br>\right . \<br>\And&amp;: \left {<br>    \begin {split}<br>              \fwt (A) _ i &amp;&#x3D; \fwt (A _ 0) _ i + \fwt (A _ 1) _ i \<br>        \fwt (A) _ {i + m} &amp;&#x3D; \fwt (A _ 0) _ i<br>    \end {split}<br>\right . \<br>\Xor&amp;: \left {<br>    \begin {split}<br>              \fwt (A) _ i &amp;&#x3D; \fwt (A _ 0) _ i + \fwt (A _ 1) _ i \<br>        \fwt (A) _ {i + m} &amp;&#x3D; \fwt (A _ 0) _ i - \fwt (A _ 1) _ i<br>    \end {split}<br>\right .<br>\end {split}<br>$$</p><p>分治解决即可。</p><h1 id="8）IFWT-还原数组"><a href="#8）IFWT-还原数组" class="headerlink" title="8）IFWT 还原数组"></a>8）IFWT 还原数组</h1><p>其实 IFWT 很简单，为什么呢？请往下看：</p><p>对于 $\Xor$ 卷积</p><p>$$<br>\begin {align}<br>      \fwt (A) _ i &amp;&#x3D; \fwt (A _ 0) _ i + \fwt (A _ 1) _ i \tag {1} \<br>\fwt (A) _ {i + m} &amp;&#x3D; \fwt (A _ 0) _ i - \fwt (A _ 1) _ i \tag {2}<br>\end {align}<br>$$</p><p>$(1)$ 式加 $(2)$ 式得：</p><p>$$<br>\begin {split}<br>    2 \fwt (A _ 0) _ i &#x3D; \fwt (A) _ i + \fwt (A) _ {i + m}<br>\end {split}<br>\Rightarrow<br>\begin {split}<br>    \fwt (A _ 0) _ i &#x3D; \dfrac {\fwt (A) _ i + \fwt (A) _ {i + m}} {2}<br>\end {split}<br>$$</p><p>$(1)$ 式减 $(2)$ 式得：</p><p>$$<br>\begin {split}<br>    2 \fwt (A _ 1) _ i &#x3D; \fwt (A) _ i - \fwt (A) _ {i + m}<br>\end {split}<br>\Rightarrow<br>\begin {split}<br>    \fwt (A _ 1) _ i &#x3D; \dfrac {\fwt (A) _ i - \fwt (A) _ {i + m}} {2}<br>\end {split}<br>$$</p><p>故</p><p>$$<br>\Xor: \left {<br>    \begin {split}<br>        \fwt (A _ 0) _ i &#x3D; \dfrac {\fwt (A) _ i + \fwt (A) _ {i + m}} {2} \<br>        \fwt (A _ 1) _ i &#x3D; \dfrac {\fwt (A) _ i - \fwt (A) _ {i + m}} {2}<br>    \end {split}<br>\right .<br>$$</p><p>其实这就是一个解方程的过程。</p><p>记住 $\fwt (A _ 0)$ 和 $\fwt (A _ 1)$ 在存储时的位置是相邻的。记 $\ifwt (A) _ i$ 表示对序列 $A$ 的 FWT 逆变换，则有：</p><p>$$<br>\Xor: \left {<br>    \begin {split}<br>              \ifwt (A) _ i &#x3D; \dfrac {\ifwt (A _ 0) _ i + \ifwt (A _ 1) _ i} {2} \<br>        \ifwt (A) _ {i + m} &#x3D; \dfrac {\ifwt (A _ 0) _ i - \ifwt (A _ 1) _ i} {2}<br>    \end {split}<br>\right .<br>$$</p><p>同理可得</p><p>$$<br>\begin {split}<br>\Or&amp;: \left {<br>    \begin {split}<br>        \ifwt (A) _ i &amp;&#x3D; \ifwt (A _ 0) _ i \<br>        \ifwt (A) _ {i + m} &amp;&#x3D; - \ifwt (A _ 0) _ i + \ifwt (A _ 1) _ i<br>    \end {split}<br>\right . \<br>\And&amp;: \left {<br>    \begin {split}<br>        \ifwt (A) _ i &amp;&#x3D; \ifwt (A _ 1) _ i \<br>        \ifwt (A) _ {i + m} &amp;&#x3D; \ifwt (A _ 0) _ i - \ifwt (A _ 1) _ i<br>    \end {split}<br>\right . \<br>\Xor&amp;: \left {<br>    \begin {split}<br>              \ifwt (A) _ i &#x3D; \dfrac {\ifwt (A _ 0) _ i + \ifwt (A _ 1) _ i} {2} \<br>        \ifwt (A) _ {i + m} &#x3D; \dfrac {\ifwt (A _ 0) _ i - \ifwt (A _ 1) _ i} {2}<br>    \end {split}<br>\right .<br>\end {split}<br>$$</p><!--\Xor&: \left \{    \begin {split}        \fwt (A _ 0) _ i = \dfrac {\fwt (A) _ i + \fwt (A) _ {i + m}} {2} \\        \fwt (A _ 1) _ i = \dfrac {\fwt (A) _ i - \fwt (A) _ {i + m}} {2}    \end {split}\right .--><p>……请大家看到这里先缓一缓……<del>公式恐惧症者保重</del></p><p>下面是对公式的汇总：</p><p>$$<br>\begin {split}<br>\Or&amp;: \left {<br>    \begin {split}<br>              \fwt (A) _ i &amp;&#x3D; \fwt (A _ 0) _ i \<br>        \fwt (A) _ {i + m} &amp;&#x3D; \fwt (A _ 0) _ i + \fwt (A _ 1) _ i<br>    \end {split}<br>\right . \<br>\And&amp;: \left {<br>    \begin {split}<br>              \fwt (A) _ i &amp;&#x3D; \fwt (A _ 0) _ i + \fwt (A _ 1) _ i \<br>        \fwt (A) _ {i + m} &amp;&#x3D; \fwt (A _ 0) _ i<br>    \end {split}<br>\right . \<br>\Xor&amp;: \left {<br>    \begin {split}<br>              \fwt (A) _ i &amp;&#x3D; \fwt (A _ 0) _ i + \fwt (A _ 1) _ i \<br>        \fwt (A) _ {i + m} &amp;&#x3D; \fwt (A _ 0) _ i - \fwt (A _ 1) _ i<br>    \end {split}<br>\right .<br>\end {split}<br>$$</p><p>$$<br>\begin {split}<br>\Or&amp;: \left {<br>    \begin {split}<br>        \ifwt (A) _ i &amp;&#x3D; \ifwt (A _ 0) _ i \<br>        \ifwt (A) _ {i + m} &amp;&#x3D; - \ifwt (A _ 0) _ i + \ifwt (A _ 1) _ i<br>    \end {split}<br>\right . \<br>\And&amp;: \left {<br>    \begin {split}<br>        \ifwt (A) _ i &amp;&#x3D; \ifwt (A _ 1) _ i \<br>        \ifwt (A) _ {i + m} &amp;&#x3D; \ifwt (A _ 0) _ i - \ifwt (A _ 1) _ i<br>    \end {split}<br>\right . \<br>\Xor&amp;: \left {<br>    \begin {split}<br>              \ifwt (A) _ i &#x3D; \dfrac {\ifwt (A _ 0) _ i + \ifwt (A _ 1) _ i} {2} \<br>        \ifwt (A) _ {i + m} &#x3D; \dfrac {\ifwt (A _ 0) _ i - \ifwt (A _ 1) _ i} {2}<br>    \end {split}<br>\right .<br>\end {split}<br>$$</p><!-- $$\begin {split}\Or&: \left \{    \begin {split}              \fwt (A _ 0) _ i &= \fwt (A) _ i \\        \fwt (A _ 1) _ i &= - \fwt (A) _ i + \fwt (A) _ {i + m}    \end {split}\right . \\\And&: \left \{    \begin {split}        \fwt (A _ 0) _ i &= \fwt (A) _ {i + m} \\              \fwt (A _ 1) _ i &= \fwt (A) _ i - \fwt (A) _ {i + m}    \end {split}\right . \\\Xor&: \left \{    \begin {split}        \fwt (A _ 0) _ i = \dfrac {\fwt (A) _ i + \fwt (A) _ {i + m}} {2} \\        \fwt (A _ 1) _ i = \dfrac {\fwt (A) _ i - \fwt (A) _ {i + m}} {2}    \end {split}\right .\end {split}$$ --><h1 id="9）迭代分治"><a href="#9）迭代分治" class="headerlink" title="9）迭代分治"></a>9）迭代分治</h1><p><del>相信写过 FFT 的同学对 FWT 的代码不成问题。</del></p><p>下面的代码是 <a href="https://www.luogu.com.cn/problem/P4717">P4717 【模板】快速沃尔什变换 (FWT)</a> 的 AC 代码，题面见链接。</p><blockquote><p>  注：笔者偷懒不想写 FWT 的 $\Or$ 和 $\And$。请读者自行脑补（滑稽）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxLog = <span class="number">17</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMaxN = (<span class="number">1</span> &lt;&lt; kMaxLog) + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kMod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> get = <span class="built_in">getchar</span>(), res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(get)) get = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(get)) &#123;</span><br><span class="line">    res = res * <span class="number">10</span> + get - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    get = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">FastPow</span><span class="params">(LL x, LL k)</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) ans = ans * x % kMod;</span><br><span class="line">    x = x * x % kMod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Times</span><span class="params">(LL* a, LL* b, LL* c, <span class="type">int</span> blen)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    c[i] = a[i] * b[i] % kMod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Print</span><span class="params">(LL* a, <span class="type">int</span> blen)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, a[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FmtOr</span><span class="params">(LL* a, <span class="type">int</span> blen, <span class="type">bool</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen), sign = opt ? +<span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; blen; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">        a[i] = (a[i] + sign * a[i ^ (<span class="number">1</span> &lt;&lt; k)] + kMod) % kMod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FmtAnd</span><span class="params">(LL* a, <span class="type">int</span> blen, <span class="type">bool</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen), sign = opt ? +<span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; blen; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (!(i &amp; (<span class="number">1</span> &lt;&lt; k)))</span><br><span class="line">        a[i] = (a[i] + sign * a[i ^ (<span class="number">1</span> &lt;&lt; k)] + kMod) % kMod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FwtXor</span><span class="params">(LL* a, <span class="type">int</span> blen, <span class="type">bool</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="number">1</span> &lt;&lt; blen);</span><br><span class="line">  <span class="comment">// 这里 1/2 的 sign 记得开 long long！</span></span><br><span class="line">  LL sign = opt ? <span class="number">1</span> : <span class="number">499122177</span>; <span class="comment">// 499122177 即为 1/2</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">      <span class="type">int</span> mid = i + (len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (len &gt;&gt; <span class="number">1</span>); ++j) &#123;</span><br><span class="line">        LL tmp1 = (a[i + j] + a[mid + j]) % kMod * sign % kMod;</span><br><span class="line">        LL tmp2 = (a[i + j] - a[mid + j] + kMod) % kMod * sign % kMod;</span><br><span class="line">        a[i + j] = tmp1;</span><br><span class="line">        a[mid + j] = tmp2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, blen; <span class="comment">// blen = bit_len</span></span><br><span class="line">LL a[kMaxN], b[kMaxN], c[kMaxN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = (<span class="number">1</span> &lt;&lt; (blen = <span class="built_in">Read</span>()));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    a[i] = <span class="built_in">Read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    b[i] = <span class="built_in">Read</span>();</span><br><span class="line">  <span class="comment">// Or 卷积</span></span><br><span class="line">  <span class="built_in">FmtOr</span>(a, blen, <span class="literal">true</span>), <span class="built_in">FmtOr</span>(b, blen, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Times</span>(a, b, c, blen);</span><br><span class="line">  <span class="built_in">FmtOr</span>(a, blen, <span class="literal">false</span>), <span class="built_in">FmtOr</span>(b, blen, <span class="literal">false</span>), <span class="built_in">FmtOr</span>(c, blen, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">Print</span>(c, blen);</span><br><span class="line">  <span class="comment">// And 卷积</span></span><br><span class="line">  <span class="built_in">FmtAnd</span>(a, blen, <span class="literal">true</span>), <span class="built_in">FmtAnd</span>(b, blen, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Times</span>(a, b, c, blen);</span><br><span class="line">  <span class="built_in">FmtAnd</span>(a, blen, <span class="literal">false</span>), <span class="built_in">FmtAnd</span>(b, blen, <span class="literal">false</span>), <span class="built_in">FmtAnd</span>(c, blen, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">Print</span>(c, blen);</span><br><span class="line">  <span class="comment">// Xor 卷积</span></span><br><span class="line">  <span class="built_in">FwtXor</span>(a, blen, <span class="literal">true</span>), <span class="built_in">FwtXor</span>(b, blen, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">Times</span>(a, b, c, blen);</span><br><span class="line">  <span class="built_in">FwtXor</span>(a, blen, <span class="literal">false</span>), <span class="built_in">FwtXor</span>(b, blen, <span class="literal">false</span>), <span class="built_in">FwtXor</span>(c, blen, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">Print</span>(c, blen);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="inf）备注"><a href="#inf）备注" class="headerlink" title="inf）备注"></a>inf）备注</h1>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学杂项</title>
      <link href="/2020-03-16-math-notes/"/>
      <url>/2020-03-16-math-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  这个页面是用来被别的页面跳转的，放一些不太好归类的数学知识在这里。</p>  <span id="more"></span><p>  链接跳转的方法是 <code>[[Link↗]](../math-notes/#note-编号)</code>。Example: <a href="#note-1">[Link↗]</a></p></blockquote><h1 id="note-1"><a href="#note-1" class="headerlink" title="note-1"></a>note-1</h1><p>$\DeclareMathOperator {\e} {e}$<strong>高维前缀和</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// len 表示 log2(n)，即 n = (1 &lt;&lt; len)。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; ++k)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">      a[i] = (a[i] + a[i ^ (<span class="number">1</span> &lt;&lt; k)]) % kMod;</span><br></pre></td></tr></table></figure><h1 id="note-2"><a href="#note-2" class="headerlink" title="note-2"></a>note-2</h1><p><strong>求导、求积分</strong></p><h2 id="note-2-1"><a href="#note-2-1" class="headerlink" title="note-2-1"></a>note-2-1</h2><p>$$<br>(A + B)’ &#x3D; A’ + B’<br>$$</p><p>这里 $A$ 和 $B$ 可以是任何式子。</p><h2 id="note-2-2"><a href="#note-2-2" class="headerlink" title="note-2-2"></a>note-2-2</h2><p>$$<br>(k A)’ &#x3D; k (A)’<br>$$</p><p>这里 $A$ 是任何式子，$k$ 为常数。</p><h2 id="note-2-3"><a href="#note-2-3" class="headerlink" title="note-2-3"></a>note-2-3</h2><p>$$<br>(a x ^ k)’ &#x3D; k a x ^ {k - 1}<br>$$</p><h2 id="note-2-4"><a href="#note-2-4" class="headerlink" title="note-2-4"></a>note-2-4</h2><p>$$<br>\int a x ^ k &#x3D; \dfrac {1} {k + 1} a ^ {k + 1} + C<br>$$</p><p>其中 $C$ 表示 $a x ^ k$ 在求导前的（被丢失的）常数项。</p><h2 id="note-2-5"><a href="#note-2-5" class="headerlink" title="note-2-5"></a>note-2-5</h2><p>$$<br>(G(F(x)))’ &#x3D; G’(F(x)) F’(x)<br>$$</p><p>注意 $G’(F(x))$ 和 $(G(F(x)))’$ 的区别。这两者是不同的。前者是函数 $G(x)$ 在 $F(x)$ 点上的导数（$\dfrac {\partial G} {\partial F}$），后者是整条式子在 $x$ 变化时的增减情况（$\dfrac {\partial G(F)} {\partial x}$）。</p><h2 id="note-2-6"><a href="#note-2-6" class="headerlink" title="note-2-6"></a>note-2-6</h2><p>$$<br>\begin {split}<br>     G(F(x)) &amp; &#x3D; \ln F(x) + A(x) \<br>    G’(F(x)) &amp; &#x3D; \dfrac {1} {F(x)}<br>\end {split}<br>$$</p><p>同上。$\ln$ 的求导法则 <a href="../math-notes/#note-4-5">[Link↗]</a>。</p><p>这里可以将 $F(x)$ 看成变量（而非函数），将 $A(x)$ 看成常数的原因，正在于 $\dfrac {\partial G} {\partial F}$ 一式上。这条式子表示对 $F$ 进行（偏）微分，也即将 $F$ 当成自变量。</p><p>也可以这样理解：将 $G(F)$ 看成以<strong>多项式交换环</strong>为定义域的函数。这样，定义了在环上的加法和乘法后，就可以将多项式 $F$ 直接当成与实数 $x$ 类似的对象。对 $x$ 所做的操作同样可以在 $F$ 上类似地实现。</p><h1 id="note-3"><a href="#note-3" class="headerlink" title="note-3"></a>note-3</h1><p>当 $|x| &lt; 1$ 时</p><p>$$<br>\displaystyle \sum _ {i &#x3D; 0} ^ {\infty} x ^ i &#x3D; \dfrac {1} {1 - x}<br>$$</p><p><strong>证明：</strong></p><p>对于 $\displaystyle \sum _ {i &#x3D; 0} ^ {n - 1} x ^ i &#x3D; 1 + x + x ^ 2 + x ^ 3 + \cdots + x ^ {n - 1}$，在两边同时乘以 $(1 - x)$，就会有：</p><p>$$<br>\begin {split}<br>      &amp; (1 - x) (1 + x + x ^ 2 + x ^ 3 + \cdots + x ^ {n - 1}) \<br>    &#x3D; &amp; 1 + x + x ^ 2 + x ^ 3 + \cdots + x ^ {n - 1} \<br>      &amp; - x - x ^ 2 - x ^ 3 - \cdots - x ^ {n - 1} - x ^ n \<br>    &#x3D; &amp; 1 - x ^ n<br>\end {split}<br>$$</p><p>由于 $1 - x \not &#x3D; 0$，所以</p><p>$$<br>1 + x + x ^ 2 + x ^ 3 + \cdots + x ^ {n - 1} &#x3D; \dfrac {1 - x ^ n} {1 - x}<br>$$</p><p>由 $|x| &lt; 1$ 知：当 $n$ 趋近于 $\infty$ 时，$x ^ n$ 趋近于 $0$，$1 - x ^ n$ 趋近于 $1$，即 $\displaystyle \sum _ {i &#x3D; 0} ^ {\infty} x ^ i &#x3D; \dfrac {1} {1 - x}$。</p><p><em>2020-03-29</em></p><h1 id="note-4"><a href="#note-4" class="headerlink" title="note-4"></a>note-4</h1><p><strong>Exp 和 Ln 相关</strong></p><h2 id="note-4-1"><a href="#note-4-1" class="headerlink" title="note-4-1"></a>note-4-1</h2><p>$$<br>(\e ^ x)’ &#x3D; \e ^ x<br>$$</p><p>常数 $\e$ 的定义（之一）</p><h2 id="note-4-2"><a href="#note-4-2" class="headerlink" title="note-4-2"></a>note-4-2</h2><p>$$<br>\e ^ x \cdot \e ^ y &#x3D; \e ^ {x + y}<br>$$</p><h2 id="note-4-3"><a href="#note-4-3" class="headerlink" title="note-4-3"></a>note-4-3</h2><p>$$<br>\ln \e ^ x &#x3D; x<br>$$</p><h2 id="note-4-4"><a href="#note-4-4" class="headerlink" title="note-4-4"></a>note-4-4</h2><p>$$<br>\ln (xy) &#x3D; \ln x + \ln y，同理 \ln \dfrac {x} {y} &#x3D; \ln x - \ln y<br>$$</p><p><strong>证明</strong>：$\ln (xy) &#x3D; \ln (\e ^ {\ln x} \cdot \e ^ {\ln y}) &#x3D; \ln \e ^ {\ln x + \ln y} &#x3D; \ln x + \ln y$</p><h2 id="note-4-5"><a href="#note-4-5" class="headerlink" title="note-4-5"></a>note-4-5</h2><p>$$<br>(\ln x)’ &#x3D; \dfrac {1} {x}<br>$$</p><p><strong>证明</strong>：设 $F(x) &#x3D; \e ^ x$，则 $F’(x) &#x3D; \e ^ x$。设 $G(x) &#x3D; \ln x$。</p><p>则 $x &#x3D; e ^ {\ln x} &#x3D; F(G(x))$。</p><p>则 $1 &#x3D; (x)’ &#x3D; (e ^ {\ln x})’ &#x3D; (F(G(x)))’ &#x3D; F’(G(x)) G’(x) &#x3D; e ^ {G(x)} G’(x) &#x3D; e ^ {\ln x} (\ln x)’ &#x3D; x (\ln x)’$</p><p>即 $1 &#x3D; x (\ln x)’$，故 $(\ln x)’ &#x3D; \dfrac {1} {x}$。</p><h2 id="note-4-6"><a href="#note-4-6" class="headerlink" title="note-4-6"></a>note-4-6</h2><p>$$<br>(\ln F(x))’ &#x3D; \dfrac {F’(x)} {F(x)}<br>$$</p><p><strong>证明</strong>：由复合函数求导 <a href="../math-notes/#note-2-5">[Link↗]</a> 及上面 $(\ln x)’ &#x3D; \dfrac {1} {x}$ <a href="../math-notes/#note-4-5">[Link↗]</a> 得出。</p><h2 id="note-4-7"><a href="#note-4-7" class="headerlink" title="note-4-7"></a>note-4-7</h2><p>$$<br>k \ln x &#x3D; \ln x ^ k<br>$$</p><p><strong>证明</strong>：$\ln x ^ k &#x3D; \ln (\e ^ {\ln x}) ^ k &#x3D; \ln e ^ {k \ln x} &#x3D; k \ln x$</p>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
